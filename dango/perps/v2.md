# V2 Features: Partial Fills from Price Constraints

> **Note:** This document describes features that may be implemented in a hypothetical "v2" release. The current implementation uses an all-or-nothing approach for price/slippage constraints.

## Overview

In v1, if an order's execution price would exceed the slippage tolerance (for market orders) or limit price (for limit orders), the entire order is rejected. In v2, we could instead compute the maximum fillable size that satisfies the price constraint and partially fill up to that amount.

This provides better UX (partial fills instead of rejections) and more closely matches traditional exchange behavior for limit orders.

## Max Fillable from Target Price Constraint

This is the complex part due to premium clamping. The execution price formula:

```plain
premium(s) = clamp((skew + s/2) / skew_scale, -M, M)
exec_price(s) = oracle_price * (1 + premium(s))
```

The premium is piecewise linear in `s`:

- **Lower clamped region**: `s <= 2*(-M*K - skew)` → `premium = -M`
- **Unclamped region**: `2*(-M*K - skew) < s < 2*(M*K - skew)` → `premium = (skew + s/2)/K`
- **Upper clamped region**: `s >= 2*(M*K - skew)` → `premium = +M`

```rust
fn compute_max_from_price(
    size: Dec,
    skew: Dec,
    pair_params: &PairParams,
    oracle_price: Udec,
    target_price: Udec,
) -> Dec {
    let K = pair_params.skew_scale;
    let M = pair_params.max_abs_premium;

    // Target premium: exec_price = oracle_price * (1 + premium)
    // For buy: need premium <= target_premium
    // For sell: need premium >= target_premium
    let target_premium = target_price / oracle_price - 1;

    // Clamping boundaries (values of s where clamping kicks in)
    let s_clamp_lower = 2 * (-M * K - skew);  // premium = -M for s <= this
    let s_clamp_upper = 2 * (M * K - skew);   // premium = +M for s >= this

    if size > 0 {
        // BUY: need premium(s) <= target_premium

        // Case 1: target_premium >= M
        // Even the max clamped premium satisfies constraint
        if target_premium >= M {
            return Dec::MAX;
        }

        // Case 2: target_premium < -M
        // Even the min premium (at s=0) doesn't satisfy
        // Wait, at s=0, premium = clamp(skew/K, -M, M)
        // Need to check marginal premium
        let marginal_premium = clamp(skew / K, -M, M);
        if marginal_premium > target_premium {
            return 0;  // Can't fill anything
        }

        // Case 3: In the middle, solve analytically
        // In unclamped region: (skew + s/2) / K <= target_premium
        // s <= 2 * (K * target_premium - skew)
        let s_unclamped = 2 * (K * target_premium - skew);

        if s_unclamped <= 0 {
            return 0;
        }

        // Check if we hit the upper clamp before the price limit
        if s_unclamped <= s_clamp_upper {
            // Price limit is reached in unclamped region
            s_unclamped
        } else {
            // We would enter upper clamped region
            // In that region, premium = M, exec_price = oracle_price * (1 + M)
            if M <= target_premium {
                Dec::MAX  // Clamped price still satisfies
            } else {
                // Can only go up to where clamping starts
                max(0, s_clamp_upper)
            }
        }
    } else {
        // SELL (size < 0): need premium(s) >= target_premium

        if target_premium <= -M {
            return Dec::MIN;  // Even min clamped premium satisfies
        }

        let marginal_premium = clamp(skew / K, -M, M);
        if marginal_premium < target_premium {
            return 0;  // Can't fill anything
        }

        // In unclamped region: (skew + s/2) / K >= target_premium
        // s >= 2 * (K * target_premium - skew)
        let s_unclamped = 2 * (K * target_premium - skew);

        if s_unclamped >= 0 {
            return 0;
        }

        if s_unclamped >= s_clamp_lower {
            s_unclamped
        } else {
            if -M >= target_premium {
                Dec::MIN
            } else {
                min(0, s_clamp_lower)
            }
        }
    }
}
```

## Modified Order Handler (V2)

In v2, the order handler would combine both OI/skew constraints and price constraints:

```rust
fn handle_submit_order_v2(
    pair_state: &mut PairState,
    pair_params: &PairParams,
    user_state: &mut UserState,
    pair_id: PairId,
    oracle_price: Udec,
    size: Dec,
    kind: OrderKind,
) {
    // ... (decompose_fill, compute max from OI/skew as before) ...

    // The maximum fill from OI/skew is closing + constrained opening
    let max_from_oi_skew = closing_size + max_opening;

    // Compute price constraint for the entire fill
    let target_price = compute_target_price(&kind, oracle_price, skew, pair_params, is_buy);
    let max_from_price = compute_max_from_price(size, skew, pair_params, oracle_price, target_price);

    // Combine all constraints
    let max_fill = if is_buy {
        min(max_from_oi_skew, max_from_price)
    } else {
        max(max_from_oi_skew, max_from_price)
    };

    // Ensure fill has correct sign
    let fill_size = if is_buy {
        max(Dec::ZERO, min(size, max_fill))
    } else {
        min(Dec::ZERO, max(size, max_fill))
    };

    // Execute the fill
    if fill_size != Dec::ZERO {
        let exec_price = compute_exec_price(oracle_price, skew, fill_size, pair_params);
        execute_fill(pair_state, user_state, pair_id, fill_size, exec_price);
    }

    // Handle unfilled portion based on order kind
    // ...
}
```

## V2 Test Cases (Price-Limited Partial Fills)

These test cases demonstrate partial fills based on price constraints:

| #   | Scenario            | user_pos | long_oi | short_oi | skew | size | kind         | fill    | exec_price | Limiting    |
| --- | ------------------- | -------- | ------- | -------- | ---- | ---- | ------------ | ------- | ---------- | ----------- |
| 11  | Buy, price-limited  | 0        | 100     | -100     | 0    | +100 | Market(1%)   | **+20** | 101        | Price       |
| 12  | Sell, price-limited | 0        | 100     | -100     | 0    | -100 | Market(1%)   | **-20** | 99         | Price       |
| 13  | Limit buy, partial  | 0        | 100     | -100     | 0    | +50  | Limit(101.5) | **+30** | 101.5      | Limit price |
| 15  | Limit sell, partial | 0        | 100     | -100     | 0    | -50  | Limit(98.5)  | **-30** | 98.5       | Limit price |

### Test 11: Buy, price-limited (V2 behavior)

**Input:** user_pos=0, long_oi=100, short_oi=-100, skew=0, size=+100, slippage=1%

1. **compute_target_price:**
   - marginal_premium = 0
   - marginal_price = 100
   - target_price = 100 * 1.01 = 101
2. **compute_max_opening_from_oi(+100):** room = 400, result = **+100**
3. **compute_max_opening_from_skew(+100, 0):** result = min(100, 300) = **+100**
4. **compute_max_from_price(+100, 0):**
   - target_premium = 101/100 - 1 = 0.01
   - 0.01 < M (0.05), not clamped
   - marginal_premium = 0 <= 0.01 ✓
   - s_unclamped = 2*(1000*0.01 - 0) = 2*10 = **+20**
   - s_clamp_upper = 2*(50 - 0) = 100
   - s_unclamped (20) <= s_clamp_upper (100), so return **+20**
5. **Combine:** max_from_oi_skew = 0 + 100 = 100
   - max_fill = min(100, 20) = 20
   - fill_size = max(0, min(100, 20)) = **+20** ✓

### Test 13: Limit buy, partial fill (V2 behavior)

**Input:** user_pos=0, long_oi=100, short_oi=-100, skew=0, size=+50, limit_price=101.5

1. **compute_target_price:** target_price = 101.5
2. **compute_max_opening_from_oi(+50):** result = **+50**
3. **compute_max_opening_from_skew(+50, 0):** result = **+50**
4. **compute_max_from_price(+50, 0):**
   - target_premium = 101.5/100 - 1 = 0.015
   - marginal_premium = 0 <= 0.015 ✓
   - s_unclamped = 2*(1000*0.015 - 0) = 2*15 = **+30**
   - Return **+30**
5. **Combine:** max_fill = min(50, 30) = 30
   - fill_size = max(0, min(50, 30)) = **+30** ✓
