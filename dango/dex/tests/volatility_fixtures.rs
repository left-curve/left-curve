/// Test fixtures for volatility estimation
///
/// These fixtures are generated by `tests/fixtures/generate_volatility_test_data.py`
/// and contain deterministic price paths with expected volatility estimates.

use {
    dango_types::dex::Price,
    grug::{Int, Timestamp},
    serde::{Deserialize, Serialize},
    std::str::FromStr,
};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PricePoint {
    pub timestamp: u128,
    pub price: String,
}

impl PricePoint {
    pub fn get_timestamp(&self) -> Timestamp {
        Timestamp::from_seconds(self.timestamp)
    }

    pub fn get_price(&self) -> Price {
        Price::raw(Int(u128::from_str(&self.price).expect("Invalid price string")))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VolatilityEstimate {
    pub timestamp: u128,
    pub estimate: String,
    pub price: String,
}

impl VolatilityEstimate {
    pub fn get_timestamp(&self) -> Timestamp {
        Timestamp::from_seconds(self.timestamp)
    }

    pub fn get_estimate(&self) -> Price {
        Price::raw(Int(u128::from_str(&self.estimate).expect("Invalid estimate string")))
    }

    pub fn get_price(&self) -> Price {
        Price::raw(Int(u128::from_str(&self.price).expect("Invalid price string")))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestScenario {
    pub name: String,
    pub description: String,
    pub initial_price: String,
    pub volatility: f64,
    pub time_step_seconds: u64,
    pub lambda_value: String,
    pub price_path: Vec<PricePoint>,
    pub expected_estimates: Vec<VolatilityEstimate>,
}

impl TestScenario {
    pub fn get_lambda(&self) -> Price {
        Price::raw(Int(u128::from_str(&self.lambda_value).expect("Invalid lambda string")))
    }

    pub fn load(name: &str) -> Self {
        let fixture_path = format!(
            "{}/dango/dex/tests/fixtures/{}.json",
            env!("CARGO_MANIFEST_DIR")
                .split("/dango/dex")
                .next()
                .unwrap(),
            name
        );
        
        let contents = std::fs::read_to_string(&fixture_path)
            .unwrap_or_else(|_| panic!("Failed to read fixture file: {}", fixture_path));
        
        serde_json::from_str(&contents)
            .unwrap_or_else(|e| panic!("Failed to parse fixture file {}: {}", fixture_path, e))
    }

    /// Load all available test scenarios
    pub fn load_all() -> Vec<Self> {
        vec![
            Self::load("single_regime_lambda_90"),
            Self::load("single_regime_lambda_95"),
            Self::load("single_regime_lambda_99"),
            Self::load("multi_phase_lambda_90"),
            Self::load("multi_phase_lambda_95"),
            Self::load("multi_phase_lambda_99"),
        ]
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_load_fixtures() {
        // Test that all fixtures can be loaded
        let scenarios = TestScenario::load_all();
        assert_eq!(scenarios.len(), 6);

        // Verify structure of first scenario
        let scenario = &scenarios[0];
        assert_eq!(scenario.name, "single_regime_lambda_90");
        assert!(!scenario.price_path.is_empty());
        assert_eq!(scenario.price_path.len(), scenario.expected_estimates.len());

        // Verify we can parse the values
        let first_price = scenario.price_path[0].get_price();
        let lambda = scenario.get_lambda();
        let first_estimate = scenario.expected_estimates[0].get_estimate();

        println!("First price: {}", first_price);
        println!("Lambda: {}", lambda);
        println!("First estimate: {}", first_estimate);
    }

    #[test]
    fn test_single_regime_lambda_90() {
        let scenario = TestScenario::load("single_regime_lambda_90");
        
        assert_eq!(scenario.name, "single_regime_lambda_90");
        assert_eq!(scenario.volatility, 0.2);
        assert_eq!(scenario.time_step_seconds, 1);
        assert_eq!(scenario.price_path.len(), 150);
        assert_eq!(scenario.expected_estimates.len(), 150);
    }

    #[test]
    fn test_multi_phase_lambda_95() {
        let scenario = TestScenario::load("multi_phase_lambda_95");
        
        assert_eq!(scenario.name, "multi_phase_lambda_95");
        assert_eq!(scenario.price_path.len(), 448);
        assert_eq!(scenario.expected_estimates.len(), 448);
    }
}

