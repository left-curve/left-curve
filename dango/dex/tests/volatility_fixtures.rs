/// Test fixtures for volatility estimation
///
/// These fixtures are generated by `tests/fixtures/generate_volatility_test_data.py`
/// and contain deterministic price paths with expected volatility estimates.
use {
    dango_types::dex::Price,
    grug::{Duration, Int, Timestamp},
    serde::{Deserialize, Serialize},
    std::str::FromStr,
};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PricePoint {
    pub timestamp: u128,
    pub price: String,
}

impl PricePoint {
    pub fn get_timestamp(&self) -> Timestamp {
        Timestamp::from_seconds(self.timestamp)
    }

    pub fn get_price(&self) -> Price {
        Price::raw(Int(
            u128::from_str(&self.price).expect("Invalid price string")
        ))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VolatilityEstimate {
    pub timestamp: u128,
    pub estimate: String,
    pub price: String,
}

impl VolatilityEstimate {
    pub fn get_timestamp(&self) -> Timestamp {
        Timestamp::from_seconds(self.timestamp)
    }

    pub fn get_estimate(&self) -> Price {
        Price::raw(Int(
            u128::from_str(&self.estimate).expect("Invalid estimate string")
        ))
    }

    pub fn get_price(&self) -> Price {
        Price::raw(Int(
            u128::from_str(&self.price).expect("Invalid price string")
        ))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestScenario {
    pub name: String,
    pub description: String,
    pub initial_price: String,
    pub volatility: f64,
    pub time_step_seconds: u64,
    pub half_life_seconds: u64,
    pub price_path: Vec<PricePoint>,
    pub expected_estimates: Vec<VolatilityEstimate>,
}

impl TestScenario {
    pub fn get_half_life(&self) -> Duration {
        Duration::from_seconds(self.half_life_seconds as u128)
    }

    pub fn load(name: &str) -> Self {
        let fixture_path = format!(
            "{}/dango/dex/tests/fixtures/{}.json",
            env!("CARGO_MANIFEST_DIR")
                .split("/dango/dex")
                .next()
                .unwrap(),
            name
        );

        let contents = std::fs::read_to_string(&fixture_path)
            .unwrap_or_else(|_| panic!("Failed to read fixture file: {}", fixture_path));

        serde_json::from_str(&contents)
            .unwrap_or_else(|e| panic!("Failed to parse fixture file {}: {}", fixture_path, e))
    }

    /// Load all available test scenarios
    pub fn load_all() -> Vec<Self> {
        vec![
            Self::load("single_regime_halflife_1s"),
            Self::load("single_regime_halflife_5s"),
            Self::load("single_regime_halflife_15s"),
            Self::load("multi_phase_halflife_1s"),
            Self::load("multi_phase_halflife_5s"),
            Self::load("multi_phase_halflife_15s"),
        ]
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_load_fixtures() {
        // Test that all fixtures can be loaded
        let scenarios = TestScenario::load_all();
        assert_eq!(scenarios.len(), 6);

        // Verify structure of first scenario
        let scenario = &scenarios[0];
        assert_eq!(scenario.name, "single_regime_halflife_1s");
        assert!(!scenario.price_path.is_empty());
        assert_eq!(scenario.price_path.len(), scenario.expected_estimates.len());

        // Verify we can parse the values
        let first_price = scenario.price_path[0].get_price();
        let half_life = scenario.get_half_life();
        let first_estimate = scenario.expected_estimates[0].get_estimate();

        println!("First price: {}", first_price);
        println!(
            "Half-life: {}ms ({} seconds)",
            half_life.into_millis(),
            half_life.into_seconds()
        );
        println!("First estimate: {}", first_estimate);
    }

    #[test]
    fn test_single_regime_halflife_1s() {
        let scenario = TestScenario::load("single_regime_halflife_1s");

        assert_eq!(scenario.name, "single_regime_halflife_1s");
        assert_eq!(scenario.volatility, 0.2);
        assert_eq!(scenario.time_step_seconds, 1);
        assert_eq!(scenario.half_life_seconds, 1);
        assert_eq!(scenario.price_path.len(), 150);
        assert_eq!(scenario.expected_estimates.len(), 150);
    }

    #[test]
    fn test_multi_phase_halflife_5s() {
        let scenario = TestScenario::load("multi_phase_halflife_5s");

        assert_eq!(scenario.name, "multi_phase_halflife_5s");
        assert_eq!(scenario.half_life_seconds, 5);
        assert_eq!(scenario.price_path.len(), 448);
        assert_eq!(scenario.expected_estimates.len(), 448);
    }
}
