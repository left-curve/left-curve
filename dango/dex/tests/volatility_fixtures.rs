/// Test fixtures for volatility estimation
///
/// These fixtures are generated by `tests/fixtures/generate_volatility_test_data.py`
/// and contain deterministic price paths with expected volatility estimates.
use {
    dango_types::dex::Price,
    grug::{Duration, Int, Timestamp},
    serde::{Deserialize, Serialize},
    std::str::FromStr,
};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PricePoint {
    pub timestamp: u128,
    pub price: String,
}

impl PricePoint {
    pub fn get_timestamp(&self) -> Timestamp {
        Timestamp::from_seconds(self.timestamp)
    }

    pub fn get_price(&self) -> Price {
        Price::raw(Int(
            u128::from_str(&self.price).expect("Invalid price string")
        ))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VolatilityEstimate {
    pub timestamp: u128,
    pub estimate: String,
    pub price: String,
}

impl VolatilityEstimate {
    pub fn get_timestamp(&self) -> Timestamp {
        Timestamp::from_seconds(self.timestamp)
    }

    pub fn get_estimate(&self) -> Price {
        Price::raw(Int(
            u128::from_str(&self.estimate).expect("Invalid estimate string")
        ))
    }

    pub fn get_price(&self) -> Price {
        Price::raw(Int(
            u128::from_str(&self.price).expect("Invalid price string")
        ))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestScenario {
    pub name: String,
    pub description: String,
    pub initial_price: String,
    pub volatility: f64,
    pub time_step_seconds: u64,
    pub lambda_value: String,
    pub price_path: Vec<PricePoint>,
    pub expected_estimates: Vec<VolatilityEstimate>,
}

impl TestScenario {
    pub fn get_lambda(&self) -> Price {
        Price::raw(Int(
            u128::from_str(&self.lambda_value).expect("Invalid lambda string")
        ))
    }

    /// Convert lambda to half_life based on the relationship:
    /// In the Python fixtures: vol_t = lambda * vol_{t-1} + (1 - lambda) * r_t^2
    /// In the Rust code: vol_t = alpha * vol_{t-1} + (1 - alpha) * r_t^2
    /// where alpha = 1 - exp(-ln(2) * dt / half_life)
    ///
    /// Therefore: lambda = alpha = 1 - exp(-ln(2) * dt / half_life)
    /// Solving for half_life: half_life = -ln(2) * dt / ln(1 - lambda)
    ///
    /// For the test fixtures, dt is the time_step_seconds.
    pub fn get_half_life(&self) -> Duration {
        let lambda = self.get_lambda();
        let lambda_f64 = lambda.0.0 as f64 / 1e24;

        // Calculate half_life in milliseconds: -ln(2) * dt_ms / ln(1 - lambda)
        let ln_2 = 0.693147180559945309417232121458;
        let ln_one_minus_lambda = (1.0 - lambda_f64).ln();
        let dt_ms = (self.time_step_seconds as f64) * 1000.0; // Convert to milliseconds
        let half_life_ms = (-ln_2 * dt_ms / ln_one_minus_lambda).round() as u128;

        Duration::from_millis(half_life_ms)
    }

    pub fn load(name: &str) -> Self {
        let fixture_path = format!(
            "{}/dango/dex/tests/fixtures/{}.json",
            env!("CARGO_MANIFEST_DIR")
                .split("/dango/dex")
                .next()
                .unwrap(),
            name
        );

        let contents = std::fs::read_to_string(&fixture_path)
            .unwrap_or_else(|_| panic!("Failed to read fixture file: {}", fixture_path));

        serde_json::from_str(&contents)
            .unwrap_or_else(|e| panic!("Failed to parse fixture file {}: {}", fixture_path, e))
    }

    /// Load all available test scenarios
    pub fn load_all() -> Vec<Self> {
        vec![
            Self::load("single_regime_lambda_90"),
            Self::load("single_regime_lambda_95"),
            Self::load("single_regime_lambda_99"),
            Self::load("multi_phase_lambda_90"),
            Self::load("multi_phase_lambda_95"),
            Self::load("multi_phase_lambda_99"),
        ]
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_load_fixtures() {
        // Test that all fixtures can be loaded
        let scenarios = TestScenario::load_all();
        assert_eq!(scenarios.len(), 6);

        // Verify structure of first scenario
        let scenario = &scenarios[0];
        assert_eq!(scenario.name, "single_regime_lambda_90");
        assert!(!scenario.price_path.is_empty());
        assert_eq!(scenario.price_path.len(), scenario.expected_estimates.len());

        // Verify we can parse the values
        let first_price = scenario.price_path[0].get_price();
        let lambda = scenario.get_lambda();
        let half_life = scenario.get_half_life();
        let first_estimate = scenario.expected_estimates[0].get_estimate();

        println!("First price: {}", first_price);
        println!("Lambda: {}", lambda);
        println!(
            "Half-life: {}ms ({} seconds)",
            half_life.into_millis(),
            half_life.into_seconds()
        );
        println!("First estimate: {}", first_estimate);
    }

    #[test]
    fn test_single_regime_lambda_90() {
        let scenario = TestScenario::load("single_regime_lambda_90");

        assert_eq!(scenario.name, "single_regime_lambda_90");
        assert_eq!(scenario.volatility, 0.2);
        assert_eq!(scenario.time_step_seconds, 1);
        assert_eq!(scenario.price_path.len(), 150);
        assert_eq!(scenario.expected_estimates.len(), 150);
    }

    #[test]
    fn test_multi_phase_lambda_95() {
        let scenario = TestScenario::load("multi_phase_lambda_95");

        assert_eq!(scenario.name, "multi_phase_lambda_95");
        assert_eq!(scenario.price_path.len(), 448);
        assert_eq!(scenario.expected_estimates.len(), 448);
    }
}
