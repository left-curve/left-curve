/// Test fixtures for volatility estimation
///
/// These fixtures are generated by `tests/fixtures/generate_volatility_test_data.py`
/// and contain deterministic price paths with expected volatility estimates.
use {
    dango_types::dex::Price,
    grug::{Inner, Int, Timestamp},
    serde::{Deserialize, Serialize},
    serde_json,
    std::str::FromStr,
    std::{collections::BTreeMap, fs},
};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PricePoint {
    pub timestamp: u128,
    pub price: String,
}

impl PricePoint {
    pub fn get_timestamp(&self) -> Timestamp {
        Timestamp::from_millis(self.timestamp)
    }

    pub fn get_price(&self) -> anyhow::Result<Price> {
        Ok(Price::raw(Int(u128::from_str(&self.price)?)))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PricePathFile {
    pub name: String,
    pub description: String,
    pub initial_price: String,
    pub volatility: f64,
    pub time_step_seconds: f64,
    pub prices: Vec<PricePoint>,
    #[serde(default)]
    pub mean_dt_ms: u64,
    #[serde(default)]
    pub std_dt_ms: u64,
    #[serde(default)]
    pub seed: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VolatilityEstimateFile {
    pub name: String,
    pub description: String,
    pub price_path_file: String, // Name of the price path file this estimates
    pub half_life_seconds: u64,  // Half-life parameter for EWMA
    pub estimates: Vec<String>, /* Array of volatility estimates (high-precision strings, one per price point) */
}

/// Get the fixtures directory path
pub fn fixtures_dir() -> std::path::PathBuf {
    let manifest_dir = env!("CARGO_MANIFEST_DIR");
    std::path::Path::new(manifest_dir)
        .parent()
        .unwrap()
        .parent()
        .unwrap()
        .join("dango/dex/tests/fixtures")
}

/// Load all price path files into a BTreeMap mapping file_name -> deserialized object
pub fn load_all_price_paths() -> std::collections::BTreeMap<String, PricePathFile> {
    let price_paths_dir = fixtures_dir().join("price_paths");
    let mut price_paths = BTreeMap::new();

    let entries = fs::read_dir(&price_paths_dir).unwrap_or_else(|e| {
        panic!(
            "Failed to read price_paths directory {:?}: {}",
            price_paths_dir, e
        )
    });

    for entry in entries {
        let entry = entry.expect("Failed to read directory entry");
        let path = entry.path();

        if path.extension().and_then(|s| s.to_str()) == Some("json") {
            let file_name = path
                .file_name()
                .and_then(|n| n.to_str())
                .expect("Invalid file name")
                .to_string();

            let contents = fs::read_to_string(&path)
                .unwrap_or_else(|e| panic!("Failed to read price path file {:?}: {}", path, e));

            let price_path: PricePathFile = serde_json::from_str(&contents)
                .unwrap_or_else(|e| panic!("Failed to parse price path file {:?}: {}", path, e));

            price_paths.insert(file_name, price_path);
        }
    }

    price_paths
}

#[cfg(test)]
mod tests {
    use {super::*, anyhow::Context, std::fs};

    /// Load all volatility estimate files
    fn load_all_volatility_estimates() -> Vec<VolatilityEstimateFile> {
        let volatility_estimates_dir = fixtures_dir().join("volatility_estimates");
        let mut estimate_files = Vec::new();

        let entries = fs::read_dir(&volatility_estimates_dir).unwrap_or_else(|e| {
            panic!(
                "Failed to read volatility_estimates directory {:?}: {}",
                volatility_estimates_dir, e
            )
        });

        for entry in entries {
            let entry = entry.expect("Failed to read directory entry");
            let path = entry.path();

            if path.extension().and_then(|s| s.to_str()) == Some("json") {
                let contents = fs::read_to_string(&path).unwrap_or_else(|e| {
                    panic!("Failed to read volatility estimate file {:?}: {}", path, e)
                });

                let estimate_file: VolatilityEstimateFile = serde_json::from_str(&contents)
                    .unwrap_or_else(|e| {
                        panic!("Failed to parse volatility estimate file {:?}: {}", path, e)
                    });

                estimate_files.push(estimate_file);
            }
        }

        estimate_files
    }

    #[test]
    fn test_all_price_paths_load() {
        let price_paths = load_all_price_paths();

        // Expected: 2 fixed interval + 9 variable dt = 11 total
        // Actually: single_regime_200ms, multi_phase_200ms, and 9 variable_dt files = 11
        // Wait, let me check the list again: I see 10 files
        // single_regime_200ms, multi_phase_200ms = 2
        // variable_dt_200ms (3), variable_dt_600ms (3), variable_dt_1000ms (3) = 9
        // Total = 11? No, I counted 10 in the list. Let me assume 10 for now.
        assert!(
            price_paths.len() >= 10,
            "Expected at least 10 price path files, got {}",
            price_paths.len()
        );

        // Verify each price path has valid data
        for (file_name, price_path) in &price_paths {
            assert!(
                !price_path.prices.is_empty(),
                "Price path {} should not be empty",
                file_name
            );
            assert!(
                !price_path.name.is_empty(),
                "Price path {} should have a name",
                file_name
            );
            assert!(
                !price_path.description.is_empty(),
                "Price path {} should have a description",
                file_name
            );

            // Verify timestamps are sequential
            for i in 1..price_path.prices.len() {
                let prev_time = price_path.prices[i - 1].timestamp;
                let curr_time = price_path.prices[i].timestamp;
                assert!(
                    curr_time > prev_time,
                    "Price path {}: Timestamps should be strictly increasing at index {}",
                    file_name,
                    i
                );
            }

            // Verify all prices can be parsed
            for (i, price_point) in price_path.prices.iter().enumerate() {
                let _ = price_point
                    .get_price()
                    .with_context(|| {
                        format!(
                            "Failed to parse price (index {}: {}) in file {}",
                            i, price_point.price, file_name,
                        )
                    })
                    .unwrap();
                let _ = price_point.get_timestamp();
            }
        }

        println!(
            "Successfully loaded and validated {} price path files",
            price_paths.len()
        );
    }

    #[test]
    fn test_all_volatility_estimates_load() {
        let estimate_files = load_all_volatility_estimates();

        // Expected: 2 fixed price paths × 3 half-lives + 9 variable price paths × 3 half-lives
        // = 6 + 27 = 33 total
        // But we have 10 price paths, so: 2 × 3 + 8 × 3 = 6 + 24 = 30?
        // Actually, let's just check it's a reasonable number
        assert!(
            estimate_files.len() >= 30,
            "Expected at least 30 volatility estimate files, got {}",
            estimate_files.len()
        );

        // Verify each estimate file has valid data
        for estimate_file in &estimate_files {
            assert!(
                !estimate_file.estimates.is_empty(),
                "Volatility estimate file {} should not be empty",
                estimate_file.name
            );
            assert!(
                !estimate_file.name.is_empty(),
                "Volatility estimate file should have a name"
            );
            assert!(
                !estimate_file.price_path_file.is_empty(),
                "Volatility estimate file {} should reference a price path file",
                estimate_file.name
            );

            // Verify all estimates can be parsed as u128
            for (idx, estimate_str) in estimate_file.estimates.iter().enumerate() {
                let _ = u128::from_str(estimate_str).unwrap_or_else(|e| {
                    panic!(
                        "Volatility estimate file {}: Invalid estimate string at index {}: {}",
                        estimate_file.name, idx, e
                    )
                });
            }
        }

        println!(
            "Successfully loaded and validated {} volatility estimate files",
            estimate_files.len()
        );
    }

    #[test]
    fn test_single_regime_200ms_parsing() {
        let fixtures_dir = fixtures_dir();
        let price_path_file = fixtures_dir.join("price_paths/single_regime_200ms.json");

        let contents = fs::read_to_string(&price_path_file)
            .unwrap_or_else(|e| panic!("Failed to read single_regime_200ms.json: {}", e));

        let price_path: PricePathFile = serde_json::from_str(&contents)
            .unwrap_or_else(|e| panic!("Failed to parse single_regime_200ms.json: {}", e));

        // Verify expected values
        assert_eq!(price_path.name, "single_regime_200ms");
        assert_eq!(price_path.volatility, 0.002);
        assert_eq!(price_path.time_step_seconds, 0.2);
        assert_eq!(price_path.mean_dt_ms, 200);
        assert_eq!(price_path.std_dt_ms, 0); // Fixed interval, no variance

        // Verify expected number of price points (18000 points = 1 hour at 200ms intervals)
        assert_eq!(
            price_path.prices.len(),
            18000,
            "Expected 18000 price points for single_regime_200ms"
        );

        // Verify first price point
        let first_point = &price_path.prices[0];
        assert_eq!(first_point.timestamp, 0);
        assert_eq!(
            first_point.price, "100000000000000004764729344",
            "First price should match initial price"
        );

        // Verify initial_price matches first price
        assert_eq!(
            price_path.initial_price, first_point.price,
            "initial_price should match first price point"
        );

        // Verify timestamps are sequential with 200ms intervals
        for i in 1..price_path.prices.len() {
            let prev_time = price_path.prices[i - 1].timestamp;
            let curr_time = price_path.prices[i].timestamp;
            let dt = curr_time - prev_time;
            assert_eq!(
                dt,
                200,
                "Expected 200ms intervals, got {}ms between index {} and {}",
                dt,
                i - 1,
                i
            );
        }

        // Verify all prices can be parsed and are valid
        for (idx, price_point) in price_path.prices.iter().enumerate() {
            let price = price_point.get_price();
            let _timestamp = price_point.get_timestamp();

            // Verify price is non-zero (except possibly first, but it should be 100.0)
            if idx == 0 {
                let price_f64 = price.unwrap().0.into_inner() as f64 / 1e24;
                assert!(
                    (price_f64 - 100.0).abs() < 0.01,
                    "First price should be approximately 100.0, got {}",
                    price_f64
                );
            }
        }

        println!("Successfully parsed and validated single_regime_200ms.json");
        println!("  Name: {}", price_path.name);
        println!("  Description: {}", price_path.description);
        println!("  Price points: {}", price_path.prices.len());
        println!("  Volatility: {}", price_path.volatility);
        println!("  Time step: {}s", price_path.time_step_seconds);
    }

    #[test]
    fn test_volatility_estimates_match_price_paths() {
        let price_paths = load_all_price_paths();
        let estimate_files = load_all_volatility_estimates();

        // Verify each volatility estimate file references a valid price path
        for estimate_file in &estimate_files {
            let price_path = price_paths
                .get(&estimate_file.price_path_file)
                .unwrap_or_else(|| {
                    panic!(
                        "Volatility estimate file '{}' references non-existent price path '{}'",
                        estimate_file.name, estimate_file.price_path_file
                    )
                });

            // Verify the number of estimates matches the number of price points
            assert_eq!(
                estimate_file.estimates.len(),
                price_path.prices.len(),
                "Volatility estimate file '{}' should have {} estimates (matching price path '{}'), but has {}",
                estimate_file.name,
                price_path.prices.len(),
                estimate_file.price_path_file,
                estimate_file.estimates.len()
            );
        }

        println!(
            "All {} volatility estimate files correctly reference price paths",
            estimate_files.len()
        );
    }
}
