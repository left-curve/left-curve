/// Deterministic tests for volatility estimation using pre-generated fixtures
///
/// These tests use price paths and expected volatility estimates generated by
/// `tests/fixtures/generate_volatility_test_data.py`. This ensures we have
/// reproducible tests running random data.
mod fixtures;

use {
    dango_dex::core::geometric::volatility_estimator::update_volatility_estimate,
    dango_types::dex::Price,
    fixtures::{PricePathFile, VolatilityEstimateFile, fixtures_dir, load_all_price_paths},
    grug::{Denom, Duration, MockStorage, Number, NumberConst, Sign},
    serde_json,
    std::{fs, str::FromStr},
};

/// Helper to compare two Price values with a relative tolerance
fn assert_price_approx_eq(actual: Price, expected: Price, tolerance: Price, message: &str) {
    let abs_diff = if actual > expected {
        actual - expected
    } else {
        expected - actual
    };

    let relative_error = (abs_diff.checked_div(expected).unwrap())
        .checked_abs()
        .unwrap();

    assert!(
        relative_error < tolerance,
        "{}: Relative error {} exceeds tolerance {}. Expected {}, got {}",
        message,
        relative_error.to_string(),
        tolerance.to_string(),
        expected.to_string(),
        actual.to_string()
    );
}

/// Test a single volatility estimate file against its corresponding price path
fn test_volatility_estimate_file(
    estimate_file: &VolatilityEstimateFile,
    price_path: &PricePathFile,
    tolerance: Price,
) {
    let mut storage = MockStorage::new();
    let base_denom = Denom::new_unchecked(vec!["base".to_string()]);
    let quote_denom = Denom::new_unchecked(vec!["quote".to_string()]);
    let half_life = Duration::from_seconds(estimate_file.half_life_seconds as u128);

    println!("\nRunning test: {}", estimate_file.name);
    println!("Description: {}", estimate_file.description);
    println!(
        "Half-life: {}ms ({} seconds)",
        half_life.into_millis(),
        half_life.into_seconds()
    );
    println!("Price path: {}", price_path.name);
    println!("Price path length: {}", price_path.prices.len());
    println!("Estimates length: {}", estimate_file.estimates.len());

    // Verify lengths match
    assert_eq!(
        price_path.prices.len(),
        estimate_file.estimates.len(),
        "Price path and estimates must have the same length for {}",
        estimate_file.name
    );

    let mut max_error = Price::ZERO;
    let mut max_error_at = 0;
    let mut total_error = Price::ZERO;
    let mut error_count = 0;

    // Zip prices with estimates and test
    for (i, (price_point, expected_estimate_str)) in price_path
        .prices
        .iter()
        .zip(estimate_file.estimates.iter())
        .enumerate()
    {
        let timestamp = price_point.get_timestamp();
        let price = price_point.get_price();
        // Parse the expected estimate string to a Price
        let expected_estimate = dango_types::dex::Price::raw(grug::Int(
            u128::from_str(expected_estimate_str).expect("Invalid estimate string"),
        ));
        let price = price.unwrap();

        // Update volatility estimate
        let actual_estimate = update_volatility_estimate(
            &mut storage,
            timestamp,
            &base_denom,
            &quote_denom,
            price,
            half_life,
        )
        .expect("Failed to update volatility estimate");

        // Compare with expected value
        // Skip first estimate (always zero) for error calculation
        if i > 0 && expected_estimate > Price::ZERO {
            let relative_error = actual_estimate
                .checked_div(expected_estimate)
                .unwrap()
                .checked_abs()
                .unwrap();
            total_error.checked_add_assign(relative_error).unwrap();
            error_count += 1;

            if relative_error > max_error {
                max_error = relative_error;
                max_error_at = i;
            }

            // Print periodic progress
            if i % 500 == 0 {
                println!(
                    "Step {}: timestamp={}ms, price={}, estimate={}, expected={}, error={:.6}",
                    i,
                    timestamp.into_millis(),
                    price,
                    actual_estimate,
                    expected_estimate,
                    relative_error
                );
            }
        }

        // Assert on each point
        assert_price_approx_eq(
            actual_estimate,
            expected_estimate,
            tolerance,
            &format!(
                "{}: Step {} at timestamp {}ms",
                estimate_file.name,
                i,
                timestamp.into_millis()
            ),
        );
    }

    // Print summary statistics
    let avg_error = if error_count > 0 {
        total_error
            .checked_div(Price::new(error_count as u128))
            .unwrap()
    } else {
        Price::ZERO
    };

    println!("\n=== Test Summary for {} ===", estimate_file.name);
    println!("Total steps: {}", price_path.prices.len());
    println!("Average relative error: {:.6}", avg_error);
    println!(
        "Maximum relative error: {:.6} at step {}",
        max_error, max_error_at
    );
    println!("Tolerance: {:.6}", tolerance);

    assert!(
        max_error < tolerance,
        "Maximum error {} exceeds tolerance {} for {}",
        max_error,
        tolerance,
        estimate_file.name
    );
}

#[test]
fn test_all_volatility_estimates() {
    // Load all price paths into a map
    let price_paths = load_all_price_paths();
    println!("Loaded {} price path files", price_paths.len());

    // Load all volatility estimate files
    let volatility_estimates_dir = fixtures_dir().join("volatility_estimates");
    let entries = fs::read_dir(&volatility_estimates_dir).unwrap_or_else(|e| {
        panic!(
            "Failed to read volatility_estimates directory {:?}: {}",
            volatility_estimates_dir, e
        )
    });

    let mut test_count = 0;
    let tolerance = 0.02; // 2% relative tolerance

    // Loop over all volatility estimate files
    for entry in entries {
        let entry = entry.expect("Failed to read directory entry");
        let path = entry.path();

        if path.extension().and_then(|s| s.to_str()) == Some("json") {
            // 1. Deserialize the volatility estimate file
            let contents = fs::read_to_string(&path).unwrap_or_else(|e| {
                panic!("Failed to read volatility estimate file {:?}: {}", path, e)
            });

            let estimate_file: VolatilityEstimateFile = serde_json::from_str(&contents)
                .unwrap_or_else(|e| {
                    panic!("Failed to parse volatility estimate file {:?}: {}", path, e)
                });

            // 2. Read the price_path_file it corresponds to
            let price_path_file_name = &estimate_file.price_path_file;

            // 3. Load that price path from the price paths map
            let price_path = price_paths.get(price_path_file_name).unwrap_or_else(|| {
                panic!(
                    "Price path file '{}' not found for volatility estimate file '{}'",
                    price_path_file_name, estimate_file.name
                )
            });

            // 4 & 5. Zip the prices with estimates and test
            test_volatility_estimate_file(&estimate_file, price_path, tolerance);
            test_count += 1;
        }
    }

    println!("\n=== All Tests Complete ===");
    println!("Tested {} volatility estimate files", test_count);
    assert!(
        test_count > 0,
        "Should have tested at least one volatility estimate file"
    );
}
