/// Deterministic tests for volatility estimation using pre-generated fixtures
///
/// These tests use price paths and expected volatility estimates generated by
/// `tests/fixtures/generate_volatility_test_data.py`. This ensures tests are:
/// 1. Deterministic - same results every time
/// 2. Verifiable - Python reference implementation produces expected values
/// 3. Reproducible - can regenerate fixtures if algorithm changes
mod volatility_fixtures;

use {
    dango_dex::core::geometric::volatilty_estimator::update_volatility_estimate,
    grug::{Denom, Inner, MockStorage},
    volatility_fixtures::TestScenario,
};

/// Helper to compare two Price values with a relative tolerance
fn assert_price_approx_eq(
    actual: dango_types::dex::Price,
    expected: dango_types::dex::Price,
    tolerance: f64,
    message: &str,
) {
    let actual_f64 = actual.0.into_inner() as f64 / 1e24;
    let expected_f64 = expected.0.into_inner() as f64 / 1e24;

    // Handle zero case
    if expected_f64.abs() < 1e-20 {
        assert!(
            actual_f64.abs() < 1e-10,
            "{}: Expected ~0, got {}",
            message,
            actual_f64
        );
        return;
    }

    let relative_error = ((actual_f64 - expected_f64) / expected_f64).abs();
    assert!(
        relative_error < tolerance,
        "{}: Relative error {} exceeds tolerance {}. Expected {}, got {}",
        message,
        relative_error,
        tolerance,
        expected_f64,
        actual_f64
    );
}

#[test]
fn test_single_regime_halflife_1s() {
    let scenario = TestScenario::load("single_regime_halflife_1s");
    run_deterministic_test(&scenario, 0.02); // 2% tolerance
}

#[test]
fn test_single_regime_halflife_5s() {
    let scenario = TestScenario::load("single_regime_halflife_5s");
    run_deterministic_test(&scenario, 0.02); // 2% tolerance
}

#[test]
fn test_single_regime_halflife_15s() {
    let scenario = TestScenario::load("single_regime_halflife_15s");
    run_deterministic_test(&scenario, 0.02); // 2% tolerance
}

#[test]
fn test_multi_phase_halflife_1s() {
    let scenario = TestScenario::load("multi_phase_halflife_1s");
    run_deterministic_test(&scenario, 0.02); // 2% tolerance
}

#[test]
fn test_multi_phase_halflife_5s() {
    let scenario = TestScenario::load("multi_phase_halflife_5s");
    run_deterministic_test(&scenario, 0.02); // 2% tolerance
}

#[test]
fn test_multi_phase_halflife_15s() {
    let scenario = TestScenario::load("multi_phase_halflife_15s");
    run_deterministic_test(&scenario, 0.02); // 2% tolerance
}

/// Run a complete deterministic test with a given scenario
fn run_deterministic_test(scenario: &TestScenario, tolerance: f64) {
    let mut storage = MockStorage::new();
    let base_denom = Denom::new_unchecked(vec!["base".to_string()]);
    let quote_denom = Denom::new_unchecked(vec!["quote".to_string()]);
    let half_life = scenario.get_half_life();

    println!("\nRunning scenario: {}", scenario.name);
    println!("Description: {}", scenario.description);
    println!(
        "Half-life: {}ms ({} seconds)",
        half_life.into_millis(),
        half_life.into_seconds()
    );
    println!("Price path length: {}", scenario.price_path.len());

    let mut max_error = 0.0f64;
    let mut max_error_at = 0;
    let mut total_error = 0.0f64;
    let mut error_count = 0;

    // Run through all price points
    for (i, (price_point, expected)) in scenario
        .price_path
        .iter()
        .zip(scenario.expected_estimates.iter())
        .enumerate()
    {
        let timestamp = price_point.get_timestamp();
        let price = price_point.get_price();
        let expected_estimate = expected.get_estimate();

        // Update volatility estimate
        let actual_estimate = update_volatility_estimate(
            &mut storage,
            timestamp,
            &base_denom,
            &quote_denom,
            price,
            half_life,
        )
        .expect("Failed to update volatility estimate");

        // Compare with expected value
        let actual_f64 = actual_estimate.0.into_inner() as f64 / 1e24;
        let expected_f64 = expected_estimate.0.into_inner() as f64 / 1e24;

        // Skip first estimate (always zero) for error calculation
        if i > 0 && expected_f64 > 1e-20 {
            let relative_error = ((actual_f64 - expected_f64) / expected_f64).abs();
            total_error += relative_error;
            error_count += 1;

            if relative_error > max_error {
                max_error = relative_error;
                max_error_at = i;
            }

            // Print periodic progress
            if i % 50 == 0 {
                println!(
                    "Step {}: timestamp={}s, price={}, estimate={}, expected={}, error={:.6}",
                    i,
                    timestamp.into_seconds(),
                    price,
                    actual_estimate,
                    expected_estimate,
                    relative_error
                );
            }
        }

        // Assert on each point
        assert_price_approx_eq(
            actual_estimate,
            expected_estimate,
            tolerance,
            &format!("Step {} at timestamp {}s", i, timestamp.into_seconds()),
        );
    }

    // Print summary statistics
    let avg_error = if error_count > 0 {
        total_error / error_count as f64
    } else {
        0.0
    };

    println!("\n=== Test Summary for {} ===", scenario.name);
    println!("Total steps: {}", scenario.price_path.len());
    println!("Average relative error: {:.6}", avg_error);
    println!(
        "Maximum relative error: {:.6} at step {}",
        max_error, max_error_at
    );
    println!("Tolerance: {:.6}", tolerance);

    assert!(
        max_error < tolerance,
        "Maximum error {} exceeds tolerance {}",
        max_error,
        tolerance
    );
}

#[test]
fn test_all_scenarios_available() {
    // Verify that all expected fixtures are loadable
    let scenarios = TestScenario::load_all();
    assert_eq!(scenarios.len(), 6, "Expected 6 test scenarios");

    // Verify each scenario has valid data
    for scenario in scenarios {
        assert!(
            !scenario.price_path.is_empty(),
            "Price path should not be empty"
        );
        assert_eq!(
            scenario.price_path.len(),
            scenario.expected_estimates.len(),
            "Price path and estimates should have same length"
        );

        // Verify values are parseable
        let _half_life = scenario.get_half_life();
        let _first_price = scenario.price_path[0].get_price();
        let _first_estimate = scenario.expected_estimates[0].get_estimate();
    }
}

#[test]
fn test_fixture_consistency() {
    // Load a scenario and verify internal consistency
    let scenario = TestScenario::load("single_regime_halflife_1s");

    // Verify timestamps are sequential
    for i in 1..scenario.price_path.len() {
        let prev_time = scenario.price_path[i - 1].timestamp;
        let curr_time = scenario.price_path[i].timestamp;
        assert!(
            curr_time > prev_time,
            "Timestamps should be strictly increasing"
        );
        assert_eq!(
            curr_time - prev_time,
            scenario.time_step_seconds as u128,
            "Time steps should be consistent"
        );
    }

    // Verify price path and estimates are aligned
    for (price_point, estimate) in scenario
        .price_path
        .iter()
        .zip(scenario.expected_estimates.iter())
    {
        assert_eq!(
            price_point.timestamp, estimate.timestamp,
            "Price and estimate timestamps should match"
        );
        assert_eq!(
            price_point.price, estimate.price,
            "Price values should match between price_path and expected_estimates"
        );
    }
}
