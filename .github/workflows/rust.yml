name: Rust

permissions: {}

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

env:
  GIT_COMMIT: ${{ github.event.workflow_run.head_sha || github.event.pull_request.head.sha || github.sha }}
  DEPLOY_BACKEND_IMAGE_TAG: latest
  DEPLOY_FRONTEND_IMAGE_TAG: latest
  # Toggle sccache in CI via repo/org variable USE_SCCACHE = 'true'
  USE_SCCACHE: ${{ vars.USE_SCCACHE }}

on:
  workflow_dispatch:
  push:
    branches:
      - "main"
      - "develop"
      # - "ui/testnet"
      # - "ui/release"
    paths:
      - ".github/workflows/rust.yml"
      - "deploy/**"
      - "dango/**"
      - "docker/**"
      - "grug/**"
      - "hyperlane/**"
      - "indexer/**"
      - "pyth/**"
      - "sdk/**"
      - "ui/**"
      - "package.json"
      - "pnpm-lock.yaml"
      - "pnpm-workspace.yaml"
      - "turbo.json"
      - "Cargo.toml"
      - "Cargo.lock"
      - "clippy.toml"
      - "rustfmt.toml"
      - ".force_backend_rebuild"
      - ".force_frontend_rebuild"
      - ".force_localdango"
      - ".force_deploy"
      - "localdango/**"
      # - "sdk/**"
      # - "ui/store/**"
      # - "ui/portal/**"
      # - "ui/applets/**"
  pull_request:
    branches:
      - "*"
    paths:
      - ".github/workflows/rust.yml"
      - "deploy/**"
      - "dango/**"
      - "docker/**"
      - "grug/**"
      - "hyperlane/**"
      - "indexer/**"
      - "pyth/**"
      - "sdk/**"
      - "ui/**"
      - "package.json"
      - "pnpm-lock.yaml"
      - "pnpm-workspace.yaml"
      - "turbo.json"
      - "Cargo.toml"
      - "Cargo.lock"
      - "clippy.toml"
      - "rustfmt.toml"
      - ".force_backend_rebuild"
      - ".force_frontend_rebuild"
      - ".force_localdango"
      - ".force_deploy"
      - "localdango/**"
      # - "sdk/**"
      # - "ui/store/**"
      # - "ui/portal/**"
      # - "ui/applets/**"

jobs:
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
      localdango: ${{ steps.filter.outputs.localdango }}
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          persist-credentials: false
          ref: ${{ github.head_ref || github.ref }}
          fetch-depth: 100
      - name: Determine affected paths
        id: filter
        uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36 # v3
        with:
          filters: |
            backend:
              - 'dango/**'
              - 'grug/**'
              - 'hyperlane/**'
              - 'indexer/**'
              - 'pyth/**'
              - 'Cargo.toml'
              - 'Cargo.lock'
              - 'clippy.toml'
              - 'rustfmt.toml'
              - 'docker/dango/**'
              - '.force_backend_rebuild'
            frontend:
              - 'sdk/**'
              - 'ui/**'
              - 'package.json'
              - 'pnpm-lock.yaml'
              - 'pnpm-workspace.yaml'
              - 'turbo.json'
              - 'biome.json'
              - 'docker/dango-frontend/**'
              - '.force_frontend_rebuild'
            localdango:
              - 'localdango/**'
              - ".force_localdango"
      - name: Add detected changes to summary
        env:
          BACKEND_STATUS: ${{ steps.filter.outputs.backend }}
          FRONTEND_STATUS: ${{ steps.filter.outputs.frontend }}
          LOCALDANGO_STATUS: ${{ steps.filter.outputs.localdango }}
        run: |
          echo "## ðŸ” Detected Changes" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Changes Detected |" >> $GITHUB_STEP_SUMMARY
          echo "| --------- | --------------- |" >> $GITHUB_STEP_SUMMARY
          backend_status="$BACKEND_STATUS"
          frontend_status="$FRONTEND_STATUS"
          localdango_status="$LOCALDANGO_STATUS"
          if [ "$backend_status" = "true" ]; then
            echo "| backend | âœ… Yes |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| backend | âŒ No |" >> $GITHUB_STEP_SUMMARY
          fi
          if [ "$frontend_status" = "true" ]; then
            echo "| frontend | âœ… Yes |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| frontend | âŒ No |" >> $GITHUB_STEP_SUMMARY
          fi
          if [ "$localdango_status" = "true" ]; then
            echo "| localdango | âœ… Yes |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| localdango | âŒ No |" >> $GITHUB_STEP_SUMMARY
          fi

  zizmor:
    uses: ./.github/workflows/zizmor.yml
    permissions:
      security-events: write
      contents: read
      actions: read

  format:
    name: Format
    needs: [changes, zizmor]
    runs-on: [self-hosted]
    permissions:
      contents: read
    env:
      BACKEND_CHANGED: ${{ needs.changes.outputs.backend }}
    # Don't use this, it raises permissions issues on self hosted runners
    # container:
    #   image: rust:slim
    steps:
      - name: Skip format (no backend changes)
        if: env.BACKEND_CHANGED != 'true'
        run: echo "No backend changes detected. Skipping rustfmt checks."
      - name: Checkout sources
        if: env.BACKEND_CHANGED == 'true'
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          persist-credentials: false
          ref: ${{ github.head_ref || github.ref }}

      - name: Install toolchain
        if: env.BACKEND_CHANGED == 'true'
        uses: dtolnay/rust-toolchain@4be9e76fd7c4901c61fb841f559994984270fce7 # stable
        with:
          toolchain: nightly
          components: rustfmt

      # This ends up being 8GB and takes 60sec to pull, which is too slow just for formatting.
      # - uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
      #   with:
      #     path: |
      #       ${HOME}/.cargo/bin/
      #       ${HOME}/.cargo/registry/index/
      #       ${HOME}/.cargo/registry/cache/
      #       ${HOME}/.cargo/git/db/
      #       target/
      #     key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}

      - name: Run rustfmt checks
        if: env.BACKEND_CHANGED == 'true'
        run: rustup run nightly cargo fmt --check --all

  check-no-features:
    needs: [backend-test, changes]
    name: Check compiling without features
    runs-on: self-hosted
    permissions:
      contents: read
    env:
      BACKEND_CHANGED: ${{ needs.changes.outputs.backend }}
    steps:
      - name: Skip no-feature check (no backend changes)
        if: env.BACKEND_CHANGED != 'true'
        run: echo "No backend changes detected. Skipping no-feature clippy check."
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        if: env.BACKEND_CHANGED == 'true'
        with:
          persist-credentials: false
          ref: ${{ github.head_ref || github.ref }}

      - name: Setup sccache (optional)
        if: env.BACKEND_CHANGED == 'true' && env.USE_SCCACHE == 'true'
        env:
          SCCACHE_BUCKET_SECRET: ${{ secrets.SCCACHE_BUCKET }}
          SCCACHE_ENDPOINT_SECRET: ${{ secrets.SCCACHE_ENDPOINT }}
          SCCACHE_REGION_SECRET: ${{ secrets.SCCACHE_REGION }}
          SCCACHE_S3_KEY_PREFIX_SECRET: ${{ secrets.SCCACHE_S3_KEY_PREFIX }}
          SCCACHE_S3_USE_SSL_SECRET: ${{ secrets.SCCACHE_S3_USE_SSL }}
          AWS_ACCESS_KEY_ID_SECRET: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY_SECRET: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          set -euo pipefail
          if ! command -v sccache >/dev/null 2>&1; then
            V=0.12.0
            ARCH=$(uname -m)
            case "$ARCH" in
              x86_64) A=x86_64 ;;
              aarch64|arm64) A=aarch64 ;;
              *) echo "Unsupported arch: $ARCH"; exit 1 ;;
            esac
            curl -sSfL -o /tmp/sccache.tar.gz "https://github.com/mozilla/sccache/releases/download/v${V}/sccache-v${V}-${A}-unknown-linux-musl.tar.gz"
            tar -xzf /tmp/sccache.tar.gz -C /tmp
            mkdir -p "$HOME/.local/bin" "$HOME/.cache/sccache"
            mv "/tmp/sccache-v${V}-${A}-unknown-linux-musl/sccache" "$HOME/.local/bin/sccache"
            chmod +x "$HOME/.local/bin/sccache"
            echo "$HOME/.local/bin" >> $GITHUB_PATH
          else
            mkdir -p "$HOME/.cache/sccache"
          fi
          {
            echo "RUSTC_WRAPPER=sccache"
            echo "SCCACHE_DIR=$HOME/.cache/sccache"
            echo "SCCACHE_CACHE_SIZE=10G"
            echo "SCCACHE_BUCKET=$SCCACHE_BUCKET_SECRET"
            echo "SCCACHE_ENDPOINT=$SCCACHE_ENDPOINT_SECRET"
            echo "SCCACHE_REGION=$SCCACHE_REGION_SECRET"
            echo "SCCACHE_S3_KEY_PREFIX=$SCCACHE_S3_KEY_PREFIX_SECRET"
            echo "SCCACHE_S3_USE_SSL=$SCCACHE_S3_USE_SSL_SECRET"
            echo "SCCACHE_S3_FORCE_PATH_STYLE=1"
            echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID_SECRET"
            echo "AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY_SECRET"
          } >> $GITHUB_ENV

      - uses: dtolnay/rust-toolchain@4be9e76fd7c4901c61fb841f559994984270fce7 # stable
        if: env.BACKEND_CHANGED == 'true'
        with:
          toolchain: stable

      - name: Install cargo-hack
        if: env.BACKEND_CHANGED == 'true'
        run: cargo install cargo-hack

      - name: Check all feature combinations with cargo hack
        if: env.BACKEND_CHANGED == 'true'
        run: cargo hack clippy --each-feature --no-dev-deps -- -D warnings

      - name: sccache stats (optional)
        if: env.BACKEND_CHANGED == 'true' && env.USE_SCCACHE == 'true'
        run: sccache --show-stats || true

  backend-test:
    needs: [format, changes]
    name: LintÂ +Â Test
    runs-on: self-hosted
    timeout-minutes: 20
    permissions:
      id-token: write
      contents: read
    # Don't use this, it raises permissions issues on self hosted runners
    # container:
    #   image: ghcr.io/left-curve/left-curve/native-builder
    # permissions:
    #   packages: read
    env:
      BACKEND_CHANGED: ${{ needs.changes.outputs.backend }}
      DB_HOST: localhost
      CLICKHOUSE_HOST: localhost
      CLICKHOUSE_PORT: 10123
      POSTGRES_PORT: 6432
      CLICKHOUSE_DATABASE: grug_test
      CLICKHOUSE_USER: default
      DATABASE_URL: "postgres://postgres:postgres@localhost:6432/dango_test"
      # Used by psql client and also passed to postgres container
      PGPASSWORD: postgres
    services:
      # PostgreSQL is started manually in a step below instead of as a service.
      # GitHub Actions services don't support passing command arguments, only
      # Docker options. We need to pass `-c max_connections=500` to handle
      # parallel test load (24 cores * ~5 connections per test > default 100).
      # postgres:
      #   image: postgres:17
      #   env:
      #     POSTGRES_PASSWORD: ${{ env.PGPASSWORD }}
      #   ports:
      #     - 127.0.0.1:6432:5432
      #   options: >-
      #     --health-cmd pg_isready
      #     --health-interval 10s
      #     --health-timeout 5s
      #     --health-retries 5
      clickhouse:
        image: clickhouse/clickhouse-server:latest@sha256:6ac0386b9be731b72b318f026e9bd200eebb0f449b341d452b49722c704a3a15
        env:
          CLICKHOUSE_DB: grug_test
          CLICKHOUSE_USER: default
          CLICKHOUSE_DEFAULT_ACCESS_MANAGEMENT: 1
        ports:
          # Using a different port to not mess with the currently running clickhouse
          - 127.0.0.1:10123:8123
        options: >-
          --health-cmd "clickhouse-client --query 'SELECT 1'"
          --health-interval 5s
          --health-timeout 5s
          --health-retries 10
          --ulimit nofile=262144:262144
    steps:
      - name: Skip backend tests (no backend changes)
        if: env.BACKEND_CHANGED != 'true'
        run: echo "No backend changes detected. Skipping backend lint/test."

      - name: Checkout sources
        if: env.BACKEND_CHANGED == 'true'
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          persist-credentials: false
          ref: ${{ github.head_ref || github.ref }}

      - name: Start PostgreSQL with increased max_connections
        if: env.BACKEND_CHANGED == 'true'
        env:
          RUN_ID: ${{ github.run_id }}
        run: |
          # Start postgres manually to pass -c max_connections=500
          # (GitHub Actions services don't support passing command args)
          # With 24 cores running tests in parallel, each test using ~5 connections,
          # we need more than the default 100 max_connections
          docker run -d \
            --name postgres-test-$RUN_ID \
            -e POSTGRES_PASSWORD=$PGPASSWORD \
            -p 127.0.0.1:6432:5432 \
            --health-cmd pg_isready \
            --health-interval 10s \
            --health-timeout 5s \
            --health-retries 5 \
            postgres:17 \
            -c max_connections=500

          # Wait for postgres to be ready
          for i in {1..30}; do
            if docker exec postgres-test-$RUN_ID pg_isready -U postgres; then
              echo "PostgreSQL is ready"
              break
            fi
            echo "Waiting for PostgreSQL..."
            sleep 1
          done

          # Verify the setting
          docker exec postgres-test-$RUN_ID psql -U postgres -c "SHOW max_connections;"

      - name: Setup sccache (optional)
        if: env.BACKEND_CHANGED == 'true' && env.USE_SCCACHE == 'true'
        env:
          SCCACHE_BUCKET_SECRET: ${{ secrets.SCCACHE_BUCKET }}
          SCCACHE_ENDPOINT_SECRET: ${{ secrets.SCCACHE_ENDPOINT }}
          SCCACHE_REGION_SECRET: ${{ secrets.SCCACHE_REGION }}
          SCCACHE_S3_KEY_PREFIX_SECRET: ${{ secrets.SCCACHE_S3_KEY_PREFIX }}
          SCCACHE_S3_USE_SSL_SECRET: ${{ secrets.SCCACHE_S3_USE_SSL }}
          AWS_ACCESS_KEY_ID_SECRET: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY_SECRET: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          set -euo pipefail
          if ! command -v sccache >/dev/null 2>&1; then
            V=0.12.0
            ARCH=$(uname -m)
            case "$ARCH" in
              x86_64) A=x86_64 ;;
              aarch64|arm64) A=aarch64 ;;
              *) echo "Unsupported arch: $ARCH"; exit 1 ;;
            esac
            curl -sSfL -o /tmp/sccache.tar.gz "https://github.com/mozilla/sccache/releases/download/v${V}/sccache-v${V}-${A}-unknown-linux-musl.tar.gz"
            tar -xzf /tmp/sccache.tar.gz -C /tmp
            mkdir -p "$HOME/.local/bin" "$HOME/.cache/sccache"
            mv "/tmp/sccache-v${V}-${A}-unknown-linux-musl/sccache" "$HOME/.local/bin/sccache"
            chmod +x "$HOME/.local/bin/sccache"
            echo "$HOME/.local/bin" >> $GITHUB_PATH
          else
            mkdir -p "$HOME/.cache/sccache"
          fi
          {
            echo "RUSTC_WRAPPER=sccache"
            echo "SCCACHE_DIR=$HOME/.cache/sccache"
            echo "SCCACHE_CACHE_SIZE=10G"
            echo "SCCACHE_BUCKET=$SCCACHE_BUCKET_SECRET"
            echo "SCCACHE_ENDPOINT=$SCCACHE_ENDPOINT_SECRET"
            echo "SCCACHE_REGION=$SCCACHE_REGION_SECRET"
            echo "SCCACHE_S3_KEY_PREFIX=$SCCACHE_S3_KEY_PREFIX_SECRET"
            echo "SCCACHE_S3_USE_SSL=$SCCACHE_S3_USE_SSL_SECRET"
            echo "SCCACHE_S3_FORCE_PATH_STYLE=1"
            echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID_SECRET"
            echo "AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY_SECRET"
          } >> $GITHUB_ENV

      - name: Install toolchain
        if: env.BACKEND_CHANGED == 'true'
        uses: dtolnay/rust-toolchain@4be9e76fd7c4901c61fb841f559994984270fce7 # stable
        with:
          # Commenting this out so we always use the latest toolchain.
          # toolchain: 1.91
          components: clippy, llvm-tools-preview

      # - uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
      #   with:
      #     path: |
      #       ${HOME}/.cargo/bin/
      #       ${HOME}/.cargo/registry/index/
      #       ${HOME}/.cargo/registry/cache/
      #       ${HOME}/.cargo/git/db/
      #       target/
      #     key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}

      - name: Run clippy
        if: env.BACKEND_CHANGED == 'true'
        run: cargo clippy --bins --tests --benches --examples --all-features --all-targets -- -D warnings

      - name: Build GraphQL schema
        if: env.BACKEND_CHANGED == 'true'
        run: cargo run -p dango-httpd build_graphql_schema -- ./indexer/client/src/schemas/schema.graphql

      - name: Check if schema is up-to-date
        if: env.BACKEND_CHANGED == 'true'
        run: |
          if ! git diff --exit-code ./indexer/client/src/schemas/schema.graphql; then
            echo "::error::GraphQL schema is out of date. Please run 'just build-graphql-schema' locally and commit the changes."
            exit 1
          fi

      - name: Install cargo-llvm-cov
        if: env.BACKEND_CHANGED == 'true'
        run: cargo install cargo-llvm-cov

      # Prior to introducing coverage, we were running tests here like this:
      # - name: Run tests
      #   run: |
      #     cargo test --all-features # -- --test-threads=1
      #   env:
      #     RUST_BACKTRACE: 1
      #
      # Leaving here since coverage takes more time than tests and we might want to revert at some point.
      - name: Run tests and collect coverage
        if: env.BACKEND_CHANGED == 'true'
        run: |
          mkdir -p target/coverage
          cargo llvm-cov --workspace --all-features \
                         --lcov  --output-path target/coverage/lcov.info
        env:
          RUST_BACKTRACE: 1

      - name: sccache stats (optional)
        if: env.BACKEND_CHANGED == 'true' && env.USE_SCCACHE == 'true'
        run: sccache --show-stats || true

      - name: Upload coverage to Qlty
        if: env.BACKEND_CHANGED == 'true'
        uses: qltysh/qlty-action/coverage@a19242102d17e497f437d7466aa01b528537e899 # v2
        with:
          files: target/coverage/lcov.info
          token: ${{ secrets.QLTY_COVERAGE_TOKEN }}

      - name: Cleanup PostgreSQL container
        if: always() && env.BACKEND_CHANGED == 'true'
        env:
          RUN_ID: ${{ github.run_id }}
        run: docker rm -f postgres-test-$RUN_ID || true

  backend-build:
    needs: [backend-test, changes]
    timeout-minutes: 20
    strategy:
      fail-fast: false
      matrix:
        arch: [amd64, arm64]
        runner:
          [self-hosted]
          # when needing to try on all runner types
          # - [self-hosted, Linux]
          # - [self-hosted, macOS]
    name: Build backend for ${{ matrix.arch }} on ${{ join(matrix.runner, ', ') }}
    runs-on: ${{ matrix.runner }}
    env:
      BACKEND_CHANGED: ${{ needs.changes.outputs.backend }}
    permissions:
      packages: write
      contents: read
    steps:
      - name: Skip backend build (no backend changes)
        if: env.BACKEND_CHANGED != 'true'
        env:
          MATRIX_ARCH: ${{ matrix.arch }}
        run: echo "No backend changes detected. Skipping backend build for $MATRIX_ARCH."
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        if: env.BACKEND_CHANGED == 'true'
        with:
          persist-credentials: false
          ref: ${{ github.head_ref || github.ref }}

      - name: Enable sccache for cross (optional)
        if: env.BACKEND_CHANGED == 'true' && env.USE_SCCACHE == 'true'
        env:
          SCCACHE_BUCKET: ${{ secrets.SCCACHE_BUCKET }}
          SCCACHE_ENDPOINT: ${{ secrets.SCCACHE_ENDPOINT }}
          SCCACHE_REGION: ${{ secrets.SCCACHE_REGION }}
          SCCACHE_S3_KEY_PREFIX: ${{ secrets.SCCACHE_S3_KEY_PREFIX }}
          SCCACHE_S3_USE_SSL: ${{ secrets.SCCACHE_S3_USE_SSL }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          set -euo pipefail
          mkdir -p "$HOME/.cache/sccache" "$PWD/.cross-cache/cargo"
          opts=""
          opts="$opts -e RUSTC_WRAPPER=/usr/local/bin/sccache"
          # Reuse the same host cache directory inside the container
          opts="$opts -e SCCACHE_DIR=/tmp/sccache"
          opts="$opts -e SCCACHE_CACHE_SIZE=10G"
          # Run container processes as the host user to avoid permission issues
          opts="$opts --user $(id -u):$(id -g)"
          # Provide a writable cargo home inside the container and persist it
          opts="$opts -e CARGO_HOME=/tmp/cargo -v $PWD/.cross-cache/cargo:/tmp/cargo"
          [ -n "$SCCACHE_BUCKET" ] && opts="$opts -e SCCACHE_BUCKET=$SCCACHE_BUCKET"
          [ -n "$SCCACHE_ENDPOINT" ] && opts="$opts -e SCCACHE_ENDPOINT=$SCCACHE_ENDPOINT"
          [ -n "$SCCACHE_REGION" ] && opts="$opts -e SCCACHE_REGION=$SCCACHE_REGION"
          [ -n "$SCCACHE_S3_KEY_PREFIX" ] && opts="$opts -e SCCACHE_S3_KEY_PREFIX=$SCCACHE_S3_KEY_PREFIX"
          [ -n "$SCCACHE_S3_USE_SSL" ] && opts="$opts -e SCCACHE_S3_USE_SSL=$SCCACHE_S3_USE_SSL"
          opts="$opts -e SCCACHE_S3_FORCE_PATH_STYLE=1"
          [ -n "$AWS_ACCESS_KEY_ID" ] && opts="$opts -e AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID"
          [ -n "$AWS_SECRET_ACCESS_KEY" ] && opts="$opts -e AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY"
          # Mount the host cache directory into the container
          opts="$opts -v $HOME/.cache/sccache:/tmp/sccache"
          echo "CROSS_CONTAINER_OPTS=$opts" >> $GITHUB_ENV

      - name: Set build config
        id: config
        if: env.BACKEND_CHANGED == 'true'
        env:
          MATRIX_ARCH: ${{ matrix.arch }}
          RUNNER_ARCH: ${{ runner.arch }}
          RUNNER_OS: ${{ runner.os }}
        run: |
          set -euo pipefail
          if [[ "$MATRIX_ARCH" == "amd64" ]]; then
            if [[ "$RUNNER_ARCH" == "X64" ]]; then
              echo "image=ghcr.io/left-curve/left-curve/native-builder:amd64" >> $GITHUB_OUTPUT
              echo "arch=x86_64" >> $GITHUB_OUTPUT
            elif [[ "$RUNNER_ARCH" == "ARM64" ]]; then
              # if [[ "$RUNNER_OS" == "macOS" ]]; then
              #   echo "Unsupported runner: OS=$RUNNER_OS, Arch=$RUNNER_ARCH, cross doesn't work with this config (sadly). We should fix this."
              #   exit 1
              # fi

              echo "image=ghcr.io/left-curve/left-curve/cross-builder-amd64" >> $GITHUB_OUTPUT
              echo "arch=arm64" >> $GITHUB_OUTPUT
            else
              echo "Unsupported runner: OS=$RUNNER_OS, Arch=$RUNNER_ARCH"
              exit 1
            fi
            echo "target=x86_64-unknown-linux-gnu" >> $GITHUB_OUTPUT
            echo "platform=linux/amd64" >> $GITHUB_OUTPUT
            echo "suffix=amd64" >> $GITHUB_OUTPUT
          elif [[ "$MATRIX_ARCH" == "arm64" ]]; then
            if [[ "$RUNNER_ARCH" == "X64" ]]; then
              echo "image=ghcr.io/left-curve/left-curve/cross-builder-arm64" >> $GITHUB_OUTPUT
            elif [[ "$RUNNER_ARCH" == "ARM64" ]]; then
              if [[ "$RUNNER_OS" == "macOS" ]]; then
                echo "image=ghcr.io/left-curve/left-curve/cross-builder-arm64" >> $GITHUB_OUTPUT
              elif [[ "$RUNNER_OS" == "Linux" ]]; then
                # NOTE: I could use a native-builder in such case, but using cross to keep consistency
                echo "image=ghcr.io/left-curve/left-curve/cross-builder-arm64" >> $GITHUB_OUTPUT
              else
                echo "Unsupported runner OS for ARM64: OS=$RUNNER_OS, Arch=$RUNNER_ARCH"
                exit 1
              fi
            else
              echo "Unsupported runner: OS=$RUNNER_OS, Arch=$RUNNER_ARCH"
              exit 1
            fi
            echo "target=aarch64-unknown-linux-gnu" >> $GITHUB_OUTPUT
            echo "platform=linux/arm64" >> $GITHUB_OUTPUT
            echo "suffix=arm64" >> $GITHUB_OUTPUT
          else
              echo "Unsupported matrix $MATRIX_ARCH"
              exit 1
          fi

      - name: Install toolchain
        if: env.BACKEND_CHANGED == 'true'
        uses: dtolnay/rust-toolchain@4be9e76fd7c4901c61fb841f559994984270fce7 # stable
        with:
          toolchain: stable

      - name: Install cross
        if: env.BACKEND_CHANGED == 'true'
        run: cargo install cross --git https://github.com/cross-rs/cross

      - name: Write Cross.toml
        if: env.BACKEND_CHANGED == 'true'
        env:
          CROSS_TARGET: ${{ steps.config.outputs.target }}
          CROSS_IMAGE: ${{ steps.config.outputs.image }}
        run: |
          echo "[target.$CROSS_TARGET]" > Cross.toml
          echo "image = \"$CROSS_IMAGE\"" >> Cross.toml

      - name: Set GIT_COMMIT
        if: env.BACKEND_CHANGED == 'true'
        run: |
          cp grug/types/src/git_info.rs grug/types/src/git_info.rs.in
          sed "s/{{GIT_COMMIT}}/$GIT_COMMIT/" grug/types/src/git_info.rs.in > grug/types/src/git_info.rs
          rm grug/types/src/git_info.rs.in

      - uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3
        if: env.BACKEND_CHANGED == 'true'

      - uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3
        if: env.BACKEND_CHANGED == 'true'
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Restore cross cache
        uses: actions/cache/restore@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
        if: env.BACKEND_CHANGED == 'true'
        with:
          path: .cross-cache
          key: cross-cache-${{ runner.os }}-${{ steps.config.outputs.target }}-${{ hashFiles('**/Cargo.lock') }}

      - name: pull cross docker builder image
        if: env.BACKEND_CHANGED == 'true'
        env:
          CROSS_IMAGE: ${{ steps.config.outputs.image }}
        run: |
          docker pull $CROSS_IMAGE

      - name: build binary with cross
        if: env.BACKEND_CHANGED == 'true'
        env:
          RUSTFLAGS: "-C debuginfo=2 -C force-frame-pointers=yes"
          CARGO_PROFILE_RELEASE_STRIP: "none"
          CROSS_TARGET: ${{ steps.config.outputs.target }}
        run: |
          set -euo pipefail
          mkdir -p .cross-cache/$CROSS_TARGET
          CROSS_TARGET_CACHE=$(pwd)/.cross-cache/$CROSS_TARGET \
          cross build --target $CROSS_TARGET --release --verbose

      - name: sccache stats (cross, optional)
        if: env.BACKEND_CHANGED == 'true' && env.USE_SCCACHE == 'true'
        env:
          CROSS_IMAGE: ${{ steps.config.outputs.image }}
        run: |
          # Best-effort: show stats in a fresh container with the same cache mounted.
          docker run --rm \
            --user $(id -u):$(id -g) \
            -e SCCACHE_DIR=/tmp/sccache \
            -v $HOME/.cache/sccache:/tmp/sccache \
            $CROSS_IMAGE \
            bash -lc 'command -v sccache && sccache --show-stats || true'

      - name: Save cross cache
        if: env.BACKEND_CHANGED == 'true' && github.event_name == 'push'
        uses: actions/cache/save@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
        with:
          path: .cross-cache
          key: cross-cache-${{ runner.os }}-${{ steps.config.outputs.target }}-${{ hashFiles('**/Cargo.lock') }}

      - name: build docker image
        if: env.BACKEND_CHANGED == 'true'
        env:
          BUILD_PLATFORM: ${{ steps.config.outputs.platform }}
          CROSS_TARGET: ${{ steps.config.outputs.target }}
          BUILD_SUFFIX: ${{ steps.config.outputs.suffix }}
        run: |
          set -euo pipefail
          docker buildx build \
            --push \
            --platform $BUILD_PLATFORM \
            --build-arg TARGET_ARCH=$CROSS_TARGET \
            --build-arg GIT_COMMIT=$GIT_COMMIT \
            --provenance=false \
            -t ghcr.io/left-curve/left-curve/dango:$GIT_COMMIT-$BUILD_SUFFIX \
            -f docker/dango/Dockerfile .

      - name: Ensure Dango works
        if: env.BACKEND_CHANGED == 'true'
        env:
          BUILD_SUFFIX: ${{ steps.config.outputs.suffix }}
        run: |
          docker run --rm ghcr.io/left-curve/left-curve/dango:$GIT_COMMIT-$BUILD_SUFFIX dango || true

  backend-push-manifest:
    permissions:
      packages: write
      id-token: write
    needs: [backend-build, changes]
    env:
      BACKEND_CHANGED: ${{ needs.changes.outputs.backend }}
    outputs:
      published: ${{ steps.publish-status.outputs.published }}
    runs-on: [self-hosted]
    steps:
      - name: Skip backend manifest publish (no backend changes)
        if: env.BACKEND_CHANGED != 'true'
        run: echo "No backend changes detected. Skipping backend manifest publish."
      - name: Log in to GHCR
        if: env.BACKEND_CHANGED == 'true'
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push multi-arch Docker manifest
        if: env.BACKEND_CHANGED == 'true'
        env:
          GIT_REF: ${{ github.ref }}
          EVENT_NAME: ${{ github.event_name }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          docker manifest create ghcr.io/left-curve/left-curve/dango:$GIT_COMMIT \
            --amend ghcr.io/left-curve/left-curve/dango:$GIT_COMMIT-amd64 \
            --amend ghcr.io/left-curve/left-curve/dango:$GIT_COMMIT-arm64

          docker manifest push --purge ghcr.io/left-curve/left-curve/dango:$GIT_COMMIT

          if [ "$GIT_REF" == "refs/heads/main" ]; then
            docker manifest create ghcr.io/left-curve/left-curve/dango:latest \
              --amend ghcr.io/left-curve/left-curve/dango:$GIT_COMMIT-amd64 \
              --amend ghcr.io/left-curve/left-curve/dango:$GIT_COMMIT-arm64

            docker manifest push --purge ghcr.io/left-curve/left-curve/dango:latest
          fi

          if [ "$EVENT_NAME" == "pull_request" ]; then
            docker manifest create ghcr.io/left-curve/left-curve/dango:pr-$PR_NUMBER-latest \
              --amend ghcr.io/left-curve/left-curve/dango:$GIT_COMMIT-amd64 \
              --amend ghcr.io/left-curve/left-curve/dango:$GIT_COMMIT-arm64
            docker manifest push --purge ghcr.io/left-curve/left-curve/dango:pr-$PR_NUMBER-latest
          fi
      - name: Install Cosign
        if: env.BACKEND_CHANGED == 'true'
        uses: sigstore/cosign-installer@d7543c93d881b35a8faa02e8e3605f69b7a1ce62 # v3.10.0
      - name: Sign backend images
        id: sign-backend
        if: env.BACKEND_CHANGED == 'true'
        env:
          COSIGN_EXPERIMENTAL: "true"
          COSIGN_YES: "true"
          COSIGN_IDENTITY: "https://github.com/${{ github.repository }}/.github/workflows/rust.yml@${{ github.ref }}"
          GIT_REF: ${{ github.ref }}
          EVENT_NAME: ${{ github.event_name }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          set -euo pipefail

          images=("ghcr.io/left-curve/left-curve/dango:$GIT_COMMIT")
          if [ "$GIT_REF" = "refs/heads/main" ]; then
            images+=("ghcr.io/left-curve/left-curve/dango:latest")
          fi
          if [ "$EVENT_NAME" = "pull_request" ]; then
            images+=("ghcr.io/left-curve/left-curve/dango:pr-$PR_NUMBER-latest")
          fi

          tmp_markdown="$(mktemp)"
          tmp_digests="$(mktemp)"
          {
            echo "| Image | Digest |"
            echo "| ---- | ------ |"
          } > "$tmp_markdown"

          for image in "${images[@]}"; do
            digest="$(docker buildx imagetools inspect "$image" | awk '/^Digest:/ {print $2; exit}')"
            if [ -z "$digest" ]; then
              echo "Unable to determine digest for $image" >&2
              exit 1
            fi
            cosign sign "$image@$digest"
            printf '%s=%s\n' "$image" "$digest" >> "$tmp_digests"
            printf '| %s | `%s` |\n' "$image" "$digest" >> "$tmp_markdown"
          done
          {
            echo "digest_table<<EOF"
            cat "$tmp_markdown"
            echo "EOF"
            echo "digests<<EOF"
            cat "$tmp_digests"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Verify backend signatures
        if: ${{ env.BACKEND_CHANGED == 'true' && steps.sign-backend.outputs.digests != '' }}
        env:
          COSIGN_EXPERIMENTAL: "true"
          COSIGN_IDENTITY: "https://github.com/${{ github.repository }}/.github/workflows/rust.yml@${{ github.ref }}"
          COSIGN_DIGESTS: ${{ steps.sign-backend.outputs.digests }}
        run: |
          set -euo pipefail
          while IFS='=' read -r image digest; do
            [ -n "$image" ] || continue
            cosign verify \
              --certificate-identity "$COSIGN_IDENTITY" \
              --certificate-oidc-issuer https://token.actions.githubusercontent.com \
              "$image@$digest" >/dev/null
          done <<< "$COSIGN_DIGESTS"

      - name: Docker Deploy Summary
        env:
          DIGEST_TABLE: ${{ steps.sign-backend.outputs.digest_table }}
          GIT_REF: ${{ github.ref }}
        if: env.BACKEND_CHANGED == 'true'
        run: |
          echo "# ðŸ³ Docker Multi-arch Manifest" >> $GITHUB_STEP_SUMMARY
          echo "| Name | Result |" >> $GITHUB_STEP_SUMMARY
          echo "| ---- | ------ |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | \`$GIT_COMMIT\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Status** | âœ… |" >> $GITHUB_STEP_SUMMARY
          echo "| **Image URL** | [ghcr.io/left-curve/left-curve/dango:$GIT_COMMIT](https://github.com/left-curve/left-curve/pkgs/container/left-curve%2Fdango) |" >> $GITHUB_STEP_SUMMARY
          if [ "$GIT_REF" == "refs/heads/main" ]; then
            echo "| **Latest tag:** | [ghcr.io/left-curve/left-curve/dango:latest](https://github.com/left-curve/left-curve/pkgs/container/left-curve%2Fdango) |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "| **Architectures** | amd64, arm64 |" >> $GITHUB_STEP_SUMMARY
          if [ -n "$DIGEST_TABLE" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## ðŸ” Signed Image Digests" >> $GITHUB_STEP_SUMMARY
            echo "$DIGEST_TABLE" >> $GITHUB_STEP_SUMMARY
          fi
      - name: Record backend manifest publication
        id: publish-status
        run: |
          if [ "${BACKEND_CHANGED}" = "true" ]; then
            echo "published=true" >> $GITHUB_OUTPUT
          else
            echo "published=false" >> $GITHUB_OUTPUT
          fi
        env:
          BACKEND_CHANGED: ${{ env.BACKEND_CHANGED }}

  frontend-build:
    needs: [changes, zizmor]
    permissions:
      packages: write
      contents: read
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: amd64
            runner: [self-hosted]
          # NOTE: building arm on `self-hosted` is very very slow
          - arch: arm64
            runner: ubuntu-24.04-arm
    name: Build frontend for ${{ matrix.arch }} on ${{ join(matrix.runner, ', ') }}
    runs-on: ${{ matrix.runner }}
    env:
      GITHUB_USER: ${{ github.actor }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      FRONTEND_CHANGED: ${{ needs.changes.outputs.frontend }}
    steps:
      - name: Skip frontend build (no frontend changes)
        if: env.FRONTEND_CHANGED != 'true'
        env:
          MATRIX_ARCH: ${{ matrix.arch }}
        run: echo "No frontend changes detected. Skipping frontend build for $MATRIX_ARCH."
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        if: env.FRONTEND_CHANGED == 'true'
        with:
          persist-credentials: false
          ref: ${{ github.head_ref || github.ref }}

      - uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3
        if: env.FRONTEND_CHANGED == 'true'

      - uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3
        if: env.FRONTEND_CHANGED == 'true'
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set build config
        id: config
        if: env.FRONTEND_CHANGED == 'true'
        env:
          MATRIX_ARCH: ${{ matrix.arch }}
        run: |
          set -euo pipefail
          if [[ "$MATRIX_ARCH" == "amd64" ]]; then
            echo "target=x86_64-unknown-linux-gnu" >> $GITHUB_OUTPUT
            echo "platform=linux/amd64" >> $GITHUB_OUTPUT
            echo "suffix=amd64" >> $GITHUB_OUTPUT
          elif [[ "$MATRIX_ARCH" == "arm64" ]]; then
            echo "target=aarch64-unknown-linux-gnu" >> $GITHUB_OUTPUT
            echo "platform=linux/arm64" >> $GITHUB_OUTPUT
            echo "suffix=arm64" >> $GITHUB_OUTPUT
          else
              echo "Unsupported matrix $MATRIX_ARCH"
              exit 1
          fi

      - name: build docker image
        if: env.FRONTEND_CHANGED == 'true'
        env:
          BUILD_PLATFORM: ${{ steps.config.outputs.platform }}
          BUILD_TARGET: ${{ steps.config.outputs.target }}
          BUILD_SUFFIX: ${{ steps.config.outputs.suffix }}
          PRIVY_APP_ID: ${{ vars.PRIVY_APP_ID_DEV }}
          PRIVY_CLIENT_ID: ${{ vars.PRIVY_CLIENT_ID_DEV }}
        run: |
          set -euo pipefail
          docker buildx build \
            --push \
            --platform $BUILD_PLATFORM \
            --build-arg TARGET_ARCH=$BUILD_TARGET \
            --build-arg GIT_COMMIT=$GIT_COMMIT \
            --build-arg GITHUB_TOKEN=$GITHUB_TOKEN \
            --build-arg PRIVY_APP_ID=$PRIVY_APP_ID \
            --build-arg PRIVY_CLIENT_ID=$PRIVY_CLIENT_ID \
            --provenance=false \
            -t ghcr.io/left-curve/left-curve/dango-frontend:$GIT_COMMIT-$BUILD_SUFFIX \
            -f docker/dango-frontend/Dockerfile .

  frontend-push-manifest:
    permissions:
      packages: write
      id-token: write
    needs: [frontend-build, changes]
    env:
      FRONTEND_CHANGED: ${{ needs.changes.outputs.frontend }}
    outputs:
      published: ${{ steps.frontend-status.outputs.published }}
    runs-on: [self-hosted]
    steps:
      - name: Skip frontend manifest publish (no frontend changes)
        if: env.FRONTEND_CHANGED != 'true'
        run: echo "No frontend changes detected. Skipping frontend manifest publish."
      - name: Log in to GHCR
        if: env.FRONTEND_CHANGED == 'true'
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push multi-arch Docker manifest
        if: env.FRONTEND_CHANGED == 'true'
        env:
          GIT_REF: ${{ github.ref }}
          EVENT_NAME: ${{ github.event_name }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          docker manifest create ghcr.io/left-curve/left-curve/dango-frontend:$GIT_COMMIT \
            --amend ghcr.io/left-curve/left-curve/dango-frontend:$GIT_COMMIT-amd64 \
            --amend ghcr.io/left-curve/left-curve/dango-frontend:$GIT_COMMIT-arm64

          docker manifest push --purge ghcr.io/left-curve/left-curve/dango-frontend:$GIT_COMMIT

          if [ "$GIT_REF" == "refs/heads/main" ]; then
            docker manifest create ghcr.io/left-curve/left-curve/dango-frontend:latest \
              --amend ghcr.io/left-curve/left-curve/dango-frontend:$GIT_COMMIT-amd64 \
              --amend ghcr.io/left-curve/left-curve/dango-frontend:$GIT_COMMIT-arm64

            docker manifest push --purge ghcr.io/left-curve/left-curve/dango-frontend:latest
          fi

          if [ "$EVENT_NAME" == "pull_request" ]; then
            docker manifest create ghcr.io/left-curve/left-curve/dango-frontend:pr-$PR_NUMBER-latest\
              --amend ghcr.io/left-curve/left-curve/dango-frontend:$GIT_COMMIT-amd64 \
              --amend ghcr.io/left-curve/left-curve/dango-frontend:$GIT_COMMIT-arm64

            docker manifest push --purge ghcr.io/left-curve/left-curve/dango-frontend:pr-$PR_NUMBER-latest
          fi
      - name: Install Cosign
        if: env.FRONTEND_CHANGED == 'true'
        uses: sigstore/cosign-installer@d7543c93d881b35a8faa02e8e3605f69b7a1ce62 # v3.10.0
      - name: Sign frontend images
        id: sign-frontend
        if: env.FRONTEND_CHANGED == 'true'
        env:
          COSIGN_EXPERIMENTAL: "true"
          COSIGN_YES: "true"
          COSIGN_IDENTITY: "https://github.com/${{ github.repository }}/.github/workflows/rust.yml@${{ github.ref }}"
          GIT_REF: ${{ github.ref }}
          EVENT_NAME: ${{ github.event_name }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          set -euo pipefail

          images=("ghcr.io/left-curve/left-curve/dango-frontend:$GIT_COMMIT")
          if [ "$GIT_REF" = "refs/heads/main" ]; then
            images+=("ghcr.io/left-curve/left-curve/dango-frontend:latest")
          fi
          if [ "$EVENT_NAME" = "pull_request" ]; then
            images+=("ghcr.io/left-curve/left-curve/dango-frontend:pr-$PR_NUMBER-latest")
          fi

          tmp_markdown="$(mktemp)"
          tmp_digests="$(mktemp)"
          {
            echo "| Image | Digest |"
            echo "| ---- | ------ |"
          } > "$tmp_markdown"

          for image in "${images[@]}"; do
            digest="$(docker buildx imagetools inspect "$image" | awk '/^Digest:/ {print $2; exit}')"
            if [ -z "$digest" ]; then
              echo "Unable to determine digest for $image" >&2
              exit 1
            fi
            cosign sign "$image@$digest"
            printf '%s=%s\n' "$image" "$digest" >> "$tmp_digests"
            printf '| %s | `%s` |\n' "$image" "$digest" >> "$tmp_markdown"
          done
          {
            echo "digest_table<<EOF"
            cat "$tmp_markdown"
            echo "EOF"
            echo "digests<<EOF"
            cat "$tmp_digests"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Verify frontend signatures
        if: ${{ env.FRONTEND_CHANGED == 'true' && steps.sign-frontend.outputs.digests != '' }}
        env:
          COSIGN_EXPERIMENTAL: "true"
          COSIGN_IDENTITY: "https://github.com/${{ github.repository }}/.github/workflows/rust.yml@${{ github.ref }}"
          COSIGN_DIGESTS: ${{ steps.sign-frontend.outputs.digests }}
        run: |
          set -euo pipefail
          while IFS='=' read -r image digest; do
            [ -n "$image" ] || continue
            cosign verify \
              --certificate-identity "$COSIGN_IDENTITY" \
              --certificate-oidc-issuer https://token.actions.githubusercontent.com \
              "$image@$digest" >/dev/null
          done <<< "$COSIGN_DIGESTS"

      - name: Frontend Docker Deploy Summary
        env:
          DIGEST_TABLE: ${{ steps.sign-frontend.outputs.digest_table }}
          GIT_REF: ${{ github.ref }}
        if: env.FRONTEND_CHANGED == 'true'
        run: |
          echo "# ðŸŽ¨ Frontend Docker Multi-arch Manifest" >> $GITHUB_STEP_SUMMARY
          echo "| Name | Result |" >> $GITHUB_STEP_SUMMARY
          echo "| ---- | ------ |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | \`$GIT_COMMIT\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Status** | âœ… |" >> $GITHUB_STEP_SUMMARY
          echo "| **Image URL** | [ghcr.io/left-curve/left-curve/dango-frontend:$GIT_COMMIT](https://github.com/left-curve/left-curve/pkgs/container/left-curve%2Fdango-frontend) |" >> $GITHUB_STEP_SUMMARY
          if [ "$GIT_REF" == "refs/heads/main" ]; then
            echo "| **Latest tag:** | [ghcr.io/left-curve/left-curve/dango-frontend:latest](https://github.com/left-curve/left-curve/pkgs/container/left-curve%2Fdango-frontend) |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "| **Architectures** | amd64, arm64 |" >> $GITHUB_STEP_SUMMARY
          if [ -n "$DIGEST_TABLE" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## ðŸ” Signed Image Digests" >> $GITHUB_STEP_SUMMARY
            echo "$DIGEST_TABLE" >> $GITHUB_STEP_SUMMARY
          fi
      - name: Record frontend manifest publication
        id: frontend-status
        run: |
          if [ "${FRONTEND_CHANGED}" = "true" ]; then
            echo "published=true" >> $GITHUB_OUTPUT
          else
            echo "published=false" >> $GITHUB_OUTPUT
          fi
        env:
          FRONTEND_CHANGED: ${{ env.FRONTEND_CHANGED }}

  set-image-tags:
    name: Detect image tags
    needs: [backend-push-manifest, frontend-push-manifest, changes]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
    # if: needs.changes.outputs.frontend == 'true' || needs.changes.outputs.backend == 'true'
    outputs:
      backend_tag: ${{ steps.determine-tags.outputs.backend_tag }}
      frontend_tag: ${{ steps.determine-tags.outputs.frontend_tag }}
      backend_digest: ${{ steps.determine-tags.outputs.backend_digest }}
      frontend_digest: ${{ steps.determine-tags.outputs.frontend_digest }}
    steps:
      - name: Log in to GHCR
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Determine deploy image tag
        id: determine-tags
        env:
          BACKEND_CHANGED: ${{ needs.changes.outputs.backend }}
          FRONTEND_CHANGED: ${{ needs.changes.outputs.frontend }}
          BACKEND_PUBLISHED: ${{ needs['backend-push-manifest'].outputs.published }}
          FRONTEND_PUBLISHED: ${{ needs['frontend-push-manifest'].outputs.published }}
          EVENT_NAME: ${{ github.event_name }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          set -euo pipefail
          backend_tag="latest"
          frontend_tag="latest"
          backend_changed="$BACKEND_CHANGED"
          frontend_changed="$FRONTEND_CHANGED"
          backend_published="$BACKEND_PUBLISHED"
          frontend_published="$FRONTEND_PUBLISHED"
          run_event="$EVENT_NAME"
          backend_image_url="ghcr.io/left-curve/left-curve/dango"
          frontend_image_url="ghcr.io/left-curve/left-curve/dango-frontend"

          commit_tag="$GIT_COMMIT"
          pr_tag=""

          if [ "$backend_published" = "true" ]; then
            backend_tag="$commit_tag"
          elif docker manifest inspect "${backend_image_url}:${commit_tag}" >/dev/null 2>&1; then
            backend_tag="$commit_tag"
          elif [ "$run_event" = "pull_request" ]; then
            pr_tag="pr-${PR_NUMBER}-latest"
            if docker manifest inspect "${backend_image_url}:${pr_tag}" >/dev/null 2>&1; then
              backend_tag="$pr_tag"
            fi
          fi

          if [ "$frontend_published" = "true" ]; then
            frontend_tag="$commit_tag"
          elif docker manifest inspect "${frontend_image_url}:${commit_tag}" >/dev/null 2>&1; then
            frontend_tag="$commit_tag"
          elif [ "$run_event" = "pull_request" ]; then
            pr_tag="pr-${PR_NUMBER}-latest"
            if docker manifest inspect "${frontend_image_url}:${pr_tag}" >/dev/null 2>&1; then
              frontend_tag="$pr_tag"
            fi
          fi
          # Resolve digests for immutable image references
          # This prevents drift when using mutable tags like 'latest'
          backend_digest=""
          frontend_digest=""

          if docker manifest inspect "${backend_image_url}:${backend_tag}" >/dev/null 2>&1; then
            backend_digest=$(docker manifest inspect "${backend_image_url}:${backend_tag}" -v 2>/dev/null | jq -r '
              if type == "array" then .[0].Descriptor.digest
              elif .Descriptor.digest then .Descriptor.digest
              else .digest // empty
              end' || echo "")
          fi

          if docker manifest inspect "${frontend_image_url}:${frontend_tag}" >/dev/null 2>&1; then
            frontend_digest=$(docker manifest inspect "${frontend_image_url}:${frontend_tag}" -v 2>/dev/null | jq -r '
              if type == "array" then .[0].Descriptor.digest
              elif .Descriptor.digest then .Descriptor.digest
              else .digest // empty
              end' || echo "")
          fi

          echo "Backend deploy image tag: $backend_tag (digest: ${backend_digest:-unknown})"
          echo "Frontend deploy image tag: $frontend_tag (digest: ${frontend_digest:-unknown})"
          echo "## Deploy Image Tags" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Tag | Digest |" >> $GITHUB_STEP_SUMMARY
          echo "| --------- | --- | ------ |" >> $GITHUB_STEP_SUMMARY
          echo "| backend | \`$backend_tag\` | \`${backend_digest:-N/A}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| frontend | \`$frontend_tag\` | \`${frontend_digest:-N/A}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| commit | \`$commit_tag\` | - |" >> $GITHUB_STEP_SUMMARY
          echo "backend_tag=$backend_tag" >> "$GITHUB_OUTPUT"
          echo "frontend_tag=$frontend_tag" >> "$GITHUB_OUTPUT"
          echo "backend_digest=$backend_digest" >> "$GITHUB_OUTPUT"
          echo "frontend_digest=$frontend_digest" >> "$GITHUB_OUTPUT"

  security-artifacts:
    name: Generate SBOMs and Scan Images
    needs: [set-image-tags, changes]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
      security-events: write
    steps:
      - name: Skip security check (no new image builds)
        if: env.FRONTEND_CHANGED != 'true' && env.BACKEND_CHANGED != 'true'
        run: echo "No changes detected. Skipping checking security."
      - name: Install Syft
        if: env.BACKEND_CHANGED == 'true' || env.FRONTEND_CHANGED == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if ! command -v syft >/dev/null 2>&1; then
            curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | GH_TOKEN="$GH_TOKEN" GITHUB_TOKEN="$GH_TOKEN" sh -s -- -b /usr/local/bin
          fi
      - name: Install Grype
        if: env.BACKEND_CHANGED == 'true' || env.FRONTEND_CHANGED == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if ! command -v grype >/dev/null 2>&1; then
            curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | GH_TOKEN="$GH_TOKEN" GITHUB_TOKEN="$GH_TOKEN" sh -s -- -b /usr/local/bin
          fi
      - name: Log in to GHCR
        if: env.BACKEND_CHANGED == 'true' || env.FRONTEND_CHANGED == 'true'
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Generate SBOM and scan
        if: env.BACKEND_CHANGED == 'true' || env.FRONTEND_CHANGED == 'true'
        env:
          SBOM_DIR: sbom
          REPORT_DIR: vuln-reports
          SARIF_DIR: sarif
          DANGO_TAG: ${{ needs.set-image-tags.outputs.backend_tag }}
          FRONTEND_TAG: ${{ needs.set-image-tags.outputs.frontend_tag }}
        run: |
          set -euo pipefail
          mkdir -p "$SBOM_DIR" "$REPORT_DIR" "$SARIF_DIR"
          failed=false
          images=(
            "ghcr.io/left-curve/left-curve/dango:${DANGO_TAG}"
            "ghcr.io/left-curve/left-curve/dango-frontend:${FRONTEND_TAG}"
          )
          for image in "${images[@]}"; do
            [ -n "$image" ] || continue
            safe_name=$(echo "$image" | tr '/:@' '___')
            sbom_file="$SBOM_DIR/${safe_name}.cdx.json"
            report_file="$REPORT_DIR/${safe_name}.txt"
            sarif_file="$SARIF_DIR/${safe_name}.sarif"
            syft scan "$image" -o cyclonedx-json > "$sbom_file"
            grype "$image" --add-cpes-if-none -o sarif > "$sarif_file"
            if ! grype "$image" --fail-on high --only-fixed --add-cpes-if-none > "$report_file"; then
              echo "::warning::High severity vulnerabilities detected for $image"
              failed=true
            fi
          done
          if [ "$failed" = "true" ]; then
            touch "$REPORT_DIR/.failed"
          fi
      - name: Upload security artifacts
        if: env.BACKEND_CHANGED == 'true' || env.FRONTEND_CHANGED == 'true'
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: security-artifacts-${{ github.run_id }}
          path: |
            sbom
            vuln-reports
      - name: Upload Grype SARIF
        if: env.BACKEND_CHANGED == 'true' || env.FRONTEND_CHANGED == 'true'
        uses: github/codeql-action/upload-sarif@cdefb33c0f6224e58673d9004f47f7cb3e328b89 # v4.31.10
        with:
          sarif_file: sarif
          category: grype
      - name: Enforce vulnerability policy
        if: env.BACKEND_CHANGED == 'true' || env.FRONTEND_CHANGED == 'true'
        run: |
          if [ -f vuln-reports/.failed ]; then
            echo "::error::Critical vulnerabilities detected in container images"
            exit 1
          fi
      - name: Document security summary
        if: env.BACKEND_CHANGED == 'true' || env.FRONTEND_CHANGED == 'true'
        run: |
          echo "## ðŸ” Supply Chain Security" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "- SBOMs generated with Syft v1.13.0" >> "$GITHUB_STEP_SUMMARY"
          echo "- Vulnerability scan performed with Grype v0.81.0 (fail-on=HIGH, only-fixed)" >> "$GITHUB_STEP_SUMMARY"

  deploy:
    permissions:
      packages: read
      deployments: write
      contents: read
    needs: [security-artifacts, set-image-tags, localdango, changes]
    runs-on: [self-hosted]
    env:
      PR_NUMBER: ${{ github.event.pull_request.number }}
      PR_BRANCH: ${{ github.event.pull_request.head.ref }}
      ANSIBLE_VAULT_PASSWORD: ${{ secrets.ANSIBLE_VAULT_PASSWORD }}
      ANSIBLE_DEBIAN_PASSWORD: ${{ secrets.ANSIBLE_DEBIAN_PASSWORD }}
      DEPLOY_BACKEND_IMAGE_TAG: ${{ needs.set-image-tags.outputs.backend_tag }}
      DEPLOY_FRONTEND_IMAGE_TAG: ${{ needs.set-image-tags.outputs.frontend_tag }}
      DEPLOY_BACKEND_DIGEST: ${{ needs.set-image-tags.outputs.backend_digest }}
      DEPLOY_FRONTEND_DIGEST: ${{ needs.set-image-tags.outputs.frontend_digest }}
      BACKEND_CHANGED: ${{ needs.changes.outputs.backend }}
      FRONTEND_CHANGED: ${{ needs.changes.outputs.frontend }}
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          persist-credentials: false
          ref: ${{ github.head_ref || github.ref }}
      - name: Log in to GHCR
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Check DEPLOY_KEY is set
        env:
          DEPLOY_KEY: ${{ secrets.DEPLOY_KEY }}
        run: |
          if [ -z "$DEPLOY_KEY" ]; then
            echo "Missing DEPLOY_KEY secret"
            exit 1
          fi
      - name: Start SSH agent
        uses: webfactory/ssh-agent@836c84ec59a0e7bc0eabc79988384eb567561ee2 # v0.7.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_KEY }}
      - name: Install Ansible
        run: |
          pipx install ansible
          pipx inject ansible jmespath
          echo "${HOME}/.local/bin" >> $GITHUB_PATH
          ln -sf ~/.local/pipx/venvs/ansible/bin/ansible-galaxy ~/.local/bin/ansible-galaxy
          ln -sf ~/.local/pipx/venvs/ansible/bin/ansible-playbook ~/.local/bin/ansible-playbook
      - name: Install collections
        run: |
          ansible-galaxy collection install -r deploy/requirements.yml
      - name: Run Ansible playbook
        env:
          GIT_REF: ${{ github.ref }}
          EVENT_NAME: ${{ github.event_name }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_HEAD_SHA: ${{ github.event.pull_request.head.sha }}
          GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cd deploy

          # Skip signature verification for images that weren't built in this workflow run
          # Ansible needs boolean false, not string "false", so we include it in the JSON
          VERIFY_SIGS_JSON=""
          if [ "$BACKEND_CHANGED" != "true" ] && [ "$FRONTEND_CHANGED" != "true" ]; then
            echo "No backend/frontend changes - skipping all cosign signature verification"
            VERIFY_SIGS_JSON=', "verify_signatures": false'
          else
            # Only verify signatures for images that were actually built
            VERIFY_SIGS_JSON=', "verify_backend_signature": '"$( [ "$BACKEND_CHANGED" = "true" ] && echo "true" || echo "false" )"''
            VERIFY_SIGS_JSON+=', "verify_frontend_signature": '"$( [ "$FRONTEND_CHANGED" = "true" ] && echo "true" || echo "false" )"''
          fi

          if [ "$GIT_REF" == "refs/heads/main" ]; then
          ansible-playbook full-app.yml -e '{"traefik_enabled": true, "cometbft_generate_keys": true, "dex_bot_enabled": true, "faucet_bot_enabled": true, "github_deployments_enabled": true, "expose_ports": false, "delete_postgres_database_at_merge": false, "delete_clickhouse_database_at_merge": false, "deploy_includes_postgres": false, "deploy_includes_clickhouse": false, "dango_network": "devnet", "chain_id": "dev-9", "deploy_env": "production", "frontend_banner": "You are using devnet", "system_wide_directories": true'"$VERIFY_SIGS_JSON"'}' -e github_sha=$GIT_COMMIT -e dango_image_tag=$DEPLOY_BACKEND_IMAGE_TAG -e frontend_image_tag=$DEPLOY_FRONTEND_IMAGE_TAG -e dango_image_digest=$DEPLOY_BACKEND_DIGEST -e frontend_image_digest=$DEPLOY_FRONTEND_DIGEST -e ghcr_token=$GHCR_TOKEN --limit 100.96.253.40,100.107.248.71
          fi

          if [ "$EVENT_NAME" == "pull_request" ]; then
          # This deletes the existing deployment, but instead use `ansible-playbook delete-full-app.yml -e deployment_name=pr-<ID>` if you need
          # ansible-playbook delete-existing-app.yml -e deployment_name=pr-${PR_NUMBER}

          ansible-playbook full-app.yml -e dango_network=pr-${PR_NUMBER} -e deployment_name=pr-${PR_NUMBER} -e github_pr_number=${PR_NUMBER} -e github_sha=${PR_HEAD_SHA} -e dango_image_tag=$DEPLOY_BACKEND_IMAGE_TAG -e frontend_image_tag=$DEPLOY_FRONTEND_IMAGE_TAG -e dango_image_digest=$DEPLOY_BACKEND_DIGEST -e frontend_image_digest=$DEPLOY_FRONTEND_DIGEST -e '{"delete_s3_backup_at_merge": true, "expose_ports": true, "cometbft_generate_keys": true, "dex_bot_enabled": true, "faucet_bot_enabled": true, "github_deployments_enabled": true, "frontend_banner": "Preview app from PR '"${PR_NUMBER}"'", "chain_id": "pr-'"${PR_NUMBER}"'", "cloudflare_tunnel_enabled": true, "s3_enabled": false'"$VERIFY_SIGS_JSON"'}' -e deploy_env=preview -e ghcr_token=$GHCR_TOKEN --limit 100.96.253.40,100.107.248.71
          fi

  localdango:
    timeout-minutes: 5
    name: Testing localdango
    runs-on: [self-hosted]
    needs: [set-image-tags, changes]
    env:
      BACKEND_CHANGED: ${{ needs.changes.outputs.backend }}
      FRONTEND_CHANGED: ${{ needs.changes.outputs.frontend }}
      LOCALDANGO_CHANGED: ${{ needs.changes.outputs.localdango }}
    permissions:
      packages: read
      contents: read
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        if: env.BACKEND_CHANGED == 'true' || env.FRONTEND_CHANGED == 'true' || env.LOCALDANGO_CHANGED == 'true'
        with:
          persist-credentials: false
          ref: ${{ github.head_ref || github.ref }}

      - uses: pnpm/action-setup@c5ba7f7862a0f64c1b1a05fbac13e0b8e86ba08c # v4
        if: env.BACKEND_CHANGED == 'true' || env.FRONTEND_CHANGED == 'true' || env.LOCALDANGO_CHANGED == 'true'
        with:
          version: 10.16.1

      - name: Setup Node.js
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4
        if: env.BACKEND_CHANGED == 'true' || env.FRONTEND_CHANGED == 'true' || env.LOCALDANGO_CHANGED == 'true'
        with:
          node-version: 24
          cache: "pnpm"

      - uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3
        if: env.BACKEND_CHANGED == 'true' || env.FRONTEND_CHANGED == 'true' || env.LOCALDANGO_CHANGED == 'true'
      - uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3
        if: env.BACKEND_CHANGED == 'true' || env.FRONTEND_CHANGED == 'true' || env.LOCALDANGO_CHANGED == 'true'
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Ensure localdango works
        if: env.BACKEND_CHANGED == 'true' || env.FRONTEND_CHANGED == 'true' || env.LOCALDANGO_CHANGED == 'true'
        env:
          DANGO_TAG: ${{ needs.set-image-tags.outputs.backend_tag }}
          FRONTEND_TAG: ${{ needs.set-image-tags.outputs.frontend_tag }}
          POSTGRES_PORT: 0
          CLICKHOUSE_PORT: 0
          DANGO_PORT: 0
          COMETBFT_PORT: 0
          COMETBFT_TAG: v0.38.21
          PYTH__ACCESS_TOKEN: ${{ secrets.PYTH__ACCESS_TOKEN }}
        run: |
          cd localdango
          cp env-example .env
          docker compose --profile dango --profile dex-bot --profile faucet -f docker-compose.dango.yml -f docker-compose.yml down -v

          docker compose --profile dango -f docker-compose.dango.yml -f docker-compose.yml pull

          docker compose --profile dango --profile dex-bot --profile faucet -f docker-compose.dango.yml -f docker-compose.yml up -d --wait || {
            # Use this if other services fail
            # docker compose logs
            docker compose logs faucet --tail=10
            docker compose logs dex-bot --tail=10
            docker compose logs cometbft --tail=100
            docker compose logs dango --tail=100
            docker compose ps
            exit 1
          }

          # Capture the actual ports assigned to the services
          DANGO_PORT=$(\
            docker compose --profile dango -f docker-compose.dango.yml -f docker-compose.yml \
              port dango 8080 | awk -F: '{print $NF}' \
          )
          FAUCET_PORT=$(\
            docker compose --profile dango -f docker-compose.dango.yml -f docker-compose.yml \
              port faucet 8082 | awk -F: '{print $NF}' \
          )

          echo "Dango is running on port $DANGO_PORT"
          echo "Faucet is running on port $FAUCET_PORT"

          # Restart the frontend container so it picks up the correct backend URLs
          export INDEXER_URL="http://localhost:$DANGO_PORT"
          export UP_URL="http://localhost:$DANGO_PORT/up"
          export FAUCET_URL="http://localhost:$FAUCET_PORT/mint"

          docker compose --profile dango -f docker-compose.dango.yml -f docker-compose.yml up -d --no-deps frontend

          docker compose ps

      - name: Verify frontend and backend connection
        if: env.BACKEND_CHANGED == 'true' || env.FRONTEND_CHANGED == 'true' || env.LOCALDANGO_CHANGED == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          FRONTEND_URL: "http://localhost:5081"
        run: |
          pnpm i --frozen-lockfile
          pnpm exec playwright install --only-shell chromium
          pnpm test:e2e

      - name: Cleanup
        if: always() && (env.BACKEND_CHANGED == 'true' || env.FRONTEND_CHANGED == 'true' || env.LOCALDANGO_CHANGED == 'true')
        run: |
          cd localdango
          docker compose --profile dango down -v || true
