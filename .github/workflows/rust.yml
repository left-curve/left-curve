name: Rust

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

env:
  GIT_COMMIT: ${{ github.event.workflow_run.head_sha || github.event.pull_request.head.sha || github.sha }}

on:
  workflow_dispatch:
    inputs:
      cometbft_tag:
        description: "Existing ghcr.io/left-curve/left-curve/cometbft tag to sign (e.g. v0.38.17)"
        required: false
      cometbft_digest:
        description: "Optional digest override (sha256:...) if you already know it"
        required: false
  push:
    branches:
      - "main"
      - "develop"
      # - "ui/testnet"
      # - "ui/release"
    paths:
      - ".github/workflows/rust.yml"
      - "deploy/**"
      - "dango/**"
      - "docker/**"
      - "grug/**"
      - "hyperlane/**"
      - "indexer/**"
      - "pyth/**"
      - "Cargo.toml"
      - "Cargo.lock"
      - "clippy.toml"
      - "rustfmt.toml"
      # - "sdk/**"
      # - "ui/store/**"
      # - "ui/portal/**"
      # - "ui/applets/**"
  pull_request:
    branches:
      - "*"
    paths:
      - ".github/workflows/rust.yml"
      - "deploy/**"
      - "dango/**"
      - "docker/**"
      - "grug/**"
      - "hyperlane/**"
      - "indexer/**"
      - "pyth/**"
      - "Cargo.toml"
      - "Cargo.lock"
      - "clippy.toml"
      - "rustfmt.toml"
      # - "sdk/**"
      # - "ui/store/**"
      # - "ui/portal/**"
      # - "ui/applets/**"

jobs:
  format:
    name: Format
    runs-on: [self-hosted]
    # Don't use this, it raises permissions issues on self hosted runners
    # container:
    #   image: rust:slim
    steps:
      - name: Checkout sources
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref || github.ref }}

      - name: Install toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: nightly
          components: rustfmt

      # This ends up being 8GB and takes 60sec to pull, which is too slow just for formatting.
      # - uses: actions/cache@v4
      #   with:
      #     path: |
      #       ${HOME}/.cargo/bin/
      #       ${HOME}/.cargo/registry/index/
      #       ${HOME}/.cargo/registry/cache/
      #       ${HOME}/.cargo/git/db/
      #       target/
      #     key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}

      - name: Run rustfmt checks
        run: rustup run nightly cargo fmt --check --all

  check-no-features:
    needs: [backend-test]
    name: Check compiling without features
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref || github.ref }}

      - uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
      - name: Check without features
        run: |
          set -euo pipefail
          for crate in $(cargo metadata --format-version=1 --no-deps | jq -r '.packages[].name'); do
            echo "Checking $crate..."
            cargo clippy -p "$crate" --bins --tests --benches --examples --no-default-features --all-targets -- -D warnings
          done

  backend-test:
    needs: [format]
    name: Lint + Test
    runs-on: self-hosted
    timeout-minutes: 20
    permissions:
      id-token: write
      contents: read
    # Don't use this, it raises permissions issues on self hosted runners
    # container:
    #   image: ghcr.io/left-curve/left-curve/native-builder
    # permissions:
    #   packages: read
    env:
      PGDATABASE: grug_test
      DB_HOST: postgres
      CLICKHOUSE_HOST: localhost
      CLICKHOUSE_PORT: 10123
      POSTGRES_PORT: 6432
      CLICKHOUSE_DATABASE: grug_test
      CLICKHOUSE_USER: default
    services:
      postgres:
        image: postgres:17
        env:
          POSTGRES_PASSWORD: postgres
        ports:
          # Using a different port to not mess with the currently running psql
          - 127.0.0.1:6432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      clickhouse:
        image: clickhouse/clickhouse-server:latest
        env:
          CLICKHOUSE_DB: grug_test
          CLICKHOUSE_USER: default
          CLICKHOUSE_DEFAULT_ACCESS_MANAGEMENT: 1
        ports:
          # Using a different port to not mess with the currently running clickhouse
          - 127.0.0.1:10123:8123
        options: >-
          --health-cmd "clickhouse-client --query 'SELECT 1'"
          --health-interval 5s
          --health-timeout 5s
          --health-retries 10
          --ulimit nofile=262144:262144
    steps:
      - name: Checkout sources
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref || github.ref }}

      - name: Install toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: 1.88
          components: clippy, llvm-tools-preview

      # - name: Create psql database
      #   run: |
      #     createdb -U postgres -h postgres "$PGDATABASE"

      # - uses: actions/cache@v4
      #   with:
      #     path: |
      #       ${HOME}/.cargo/bin/
      #       ${HOME}/.cargo/registry/index/
      #       ${HOME}/.cargo/registry/cache/
      #       ${HOME}/.cargo/git/db/
      #       target/
      #     key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}

      - name: Run clippy
        run: cargo clippy --bins --tests --benches --examples --all-features --all-targets -- -D warnings

      - name: Build GraphQL schema
        run: cargo run -p dango-httpd build_graphql_schema -- ./indexer/client/src/schemas/schema.graphql

      - name: Check if schema is up-to-date
        run: |
          if ! git diff --exit-code ./indexer/client/src/schemas/schema.graphql; then
            echo "::error::GraphQL schema is out of date. Please run 'just build-graphql-schema' locally and commit the changes."
            exit 1
          fi

      - name: Install cargo-llvm-cov
        run: cargo install cargo-llvm-cov

      # Prior to introducing coverage, we were running tests here like this:
      # - name: Run tests
      #   run: |
      #     cargo test --all-features # -- --test-threads=1
      #   env:
      #     RUST_BACKTRACE: 1
      #
      # Leaving here since coverage takes more time than tests and we might want to revert at some point.
      - name: Run tests and collect coverage
        run: |
          mkdir -p target/coverage
          cargo llvm-cov --workspace --all-features \
                         --lcov  --output-path target/coverage/lcov.info
        env:
          RUST_BACKTRACE: 1

      - name: Upload coverage to Qlty
        uses: qltysh/qlty-action/coverage@v2
        with:
          files: target/coverage/lcov.info
          token: ${{ secrets.QLTY_COVERAGE_TOKEN }}

  backend-build:
    timeout-minutes: 20
    strategy:
      fail-fast: false
      matrix:
        arch: [amd64, arm64]
        runner:
          [self-hosted]
          # when needing to try on all runner types
          # - [self-hosted, Linux]
          # - [self-hosted, macOS]
    name: Build backend for ${{ matrix.arch }} on ${{ join(matrix.runner, ', ') }}
    runs-on: ${{ matrix.runner }}
    needs: [backend-test]
    permissions:
      packages: write
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref || github.ref }}

      - name: Set build config
        id: config
        run: |
          set -euo pipefail
          if [[ "${{ matrix.arch }}" == "amd64" ]]; then
            if [[ "${{ runner.arch }}" == "X64" ]]; then
              echo "image=ghcr.io/left-curve/left-curve/native-builder:amd64" >> $GITHUB_OUTPUT
              echo "arch=x86_64" >> $GITHUB_OUTPUT
            elif [[ "${{ runner.arch }}" == "ARM64" ]]; then
              # if [[ "${{ runner.os }}" == "macOS" ]]; then
              #   echo "Unsupported runner: OS=${{ runner.os }}, Arch=${{ runner.arch }}, cross doesn't work with this config (sadly). We should fix this."
              #   exit 1
              # fi

              echo "image=ghcr.io/left-curve/left-curve/cross-builder-amd64" >> $GITHUB_OUTPUT
              echo "arch=arm64" >> $GITHUB_OUTPUT
            else
              echo "Unsupported runner: OS=${{ runner.os }}, Arch=${{ runner.arch }}"
              exit 1
            fi
            echo "target=x86_64-unknown-linux-gnu" >> $GITHUB_OUTPUT
            echo "platform=linux/amd64" >> $GITHUB_OUTPUT
            echo "suffix=amd64" >> $GITHUB_OUTPUT
          elif [[ "${{ matrix.arch }}" == "arm64" ]]; then
            if [[ "${{ runner.arch }}" == "X64" ]]; then
              echo "image=ghcr.io/left-curve/left-curve/cross-builder-arm64" >> $GITHUB_OUTPUT
            elif [[ "${{ runner.arch }}" == "ARM64" ]]; then
              if [[ "${{ runner.os }}" == "macOS" ]]; then
                echo "image=ghcr.io/left-curve/left-curve/cross-builder-arm64" >> $GITHUB_OUTPUT
              elif [[ "${{ runner.os }}" == "Linux" ]]; then
                # NOTE: I could use a native-builder in such case, but using cross to keep consistency
                echo "image=ghcr.io/left-curve/left-curve/cross-builder-arm64" >> $GITHUB_OUTPUT
              else
                echo "Unsupported runner OS for ARM64: OS=${{ runner.os }}, Arch=${{ runner.arch }}"
                exit 1
              fi
            else
              echo "Unsupported runner: OS=${{ runner.os }}, Arch=${{ runner.arch }}"
              exit 1
            fi
            echo "target=aarch64-unknown-linux-gnu" >> $GITHUB_OUTPUT
            echo "platform=linux/arm64" >> $GITHUB_OUTPUT
            echo "suffix=arm64" >> $GITHUB_OUTPUT
          else
              echo "Unsupported matrix ${{ matrix.arch }}"
              exit 1
          fi

      - name: Install toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Install cross
        run: cargo install cross --git https://github.com/cross-rs/cross

      - name: Write Cross.toml
        run: |
          echo "[target.${{ steps.config.outputs.target }}]" > Cross.toml
          echo "image = \"${{ steps.config.outputs.image }}\"" >> Cross.toml

      - name: Set GIT_COMMIT
        run: |
          cp grug/types/src/git_info.rs grug/types/src/git_info.rs.in
          sed "s/{{GIT_COMMIT}}/${{ env.GIT_COMMIT }}/" grug/types/src/git_info.rs.in > grug/types/src/git_info.rs
          rm grug/types/src/git_info.rs.in

      - uses: docker/setup-buildx-action@v3

      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - uses: actions/cache@v4
        with:
          path: .cross-cache
          key: cross-cache-${{ runner.os }}-${{ steps.config.outputs.target }}-${{ hashFiles('**/Cargo.lock') }}

      - name: pull cross docker builder image
        run: |
          docker pull ${{ steps.config.outputs.image }}

      - name: build binary with cross
        run: |
          set -euo pipefail
          mkdir -p .cross-cache/${{ steps.config.outputs.target }}
          CROSS_TARGET_CACHE=$(pwd)/.cross-cache/${{ steps.config.outputs.target }} \
          cross build --target ${{ steps.config.outputs.target }} --release --verbose

      - name: build docker image
        run: |
          set -euo pipefail
          docker buildx build \
            --push \
            --platform ${{ steps.config.outputs.platform }} \
            --build-arg TARGET_ARCH=${{ steps.config.outputs.target }} \
            --build-arg GIT_COMMIT=${{ env.GIT_COMMIT }} \
            --provenance=false \
            -t ghcr.io/left-curve/left-curve/dango:${{ env.GIT_COMMIT }}-${{ steps.config.outputs.suffix }} \
            -f docker/dango/Dockerfile .

      - name: Ensure Dango works
        run: |
          docker run --rm ghcr.io/left-curve/left-curve/dango:${{ env.GIT_COMMIT }}-${{ steps.config.outputs.suffix }} dango || true

  backend-push-manifest:
    permissions:
      packages: write
      id-token: write
    needs: [backend-build]
    runs-on: [self-hosted]
    steps:
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push multi-arch Docker manifest
        run: |
          docker manifest create ghcr.io/left-curve/left-curve/dango:${{ env.GIT_COMMIT }} \
            --amend ghcr.io/left-curve/left-curve/dango:${{ env.GIT_COMMIT }}-amd64 \
            --amend ghcr.io/left-curve/left-curve/dango:${{ env.GIT_COMMIT }}-arm64

          docker manifest push --purge ghcr.io/left-curve/left-curve/dango:${{ env.GIT_COMMIT }}

          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            docker manifest create ghcr.io/left-curve/left-curve/dango:latest \
              --amend ghcr.io/left-curve/left-curve/dango:${{ env.GIT_COMMIT }}-amd64 \
              --amend ghcr.io/left-curve/left-curve/dango:${{ env.GIT_COMMIT }}-arm64

            docker manifest push --purge ghcr.io/left-curve/left-curve/dango:latest
          fi

          if [ "${{ github.event_name }}" == "pull_request" ]; then
            docker manifest create ghcr.io/left-curve/left-curve/dango:pr-${{ github.event.pull_request.number }}-latest \
              --amend ghcr.io/left-curve/left-curve/dango:${{ env.GIT_COMMIT }}-amd64 \
              --amend ghcr.io/left-curve/left-curve/dango:${{ env.GIT_COMMIT }}-arm64
            docker manifest push --purge ghcr.io/left-curve/left-curve/dango:pr-${{ github.event.pull_request.number }}-latest
          fi
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.10.0
      - name: Sign backend images
        id: sign-backend
        env:
          COSIGN_EXPERIMENTAL: "true"
          COSIGN_YES: "true"
        run: |
          set -euo pipefail

          images=("ghcr.io/left-curve/left-curve/dango:${{ env.GIT_COMMIT }}")
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            images+=("ghcr.io/left-curve/left-curve/dango:latest")
          fi
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            images+=("ghcr.io/left-curve/left-curve/dango:pr-${{ github.event.pull_request.number }}-latest")
          fi

          tmp_markdown="$(mktemp)"
          {
            echo "| Image | Digest |"
            echo "| ---- | ------ |"
          } > "$tmp_markdown"

          for image in "${images[@]}"; do
            cosign sign --keyless "$image"
            digest="$(docker buildx imagetools inspect "$image" | awk '/^Digest:/ {print $2; exit}')"
            if [ -z "$digest" ]; then
              echo "Unable to determine digest for $image" >&2
              exit 1
            fi
            printf '| %s | `%s` |\n' "$image" "$digest" >> "$tmp_markdown"
          done

          {
            echo "digest_table<<'EOF'"
            cat "$tmp_markdown"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Docker Deploy Summary
        env:
          DIGEST_TABLE: ${{ steps.sign-backend.outputs.digest_table }}
        run: |
          echo "# 🐳 Docker Multi-arch Manifest" >> $GITHUB_STEP_SUMMARY
          echo "| Name | Result |" >> $GITHUB_STEP_SUMMARY
          echo "| ---- | ------ |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | \`${{ env.GIT_COMMIT }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Status** | ✅ |" >> $GITHUB_STEP_SUMMARY
          echo "| **Image URL** | [ghcr.io/left-curve/left-curve/dango:${{ env.GIT_COMMIT }}](https://github.com/left-curve/left-curve/pkgs/container/left-curve%2Fdango) |" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "| **Latest tag:** | [ghcr.io/left-curve/left-curve/dango:latest](https://github.com/left-curve/left-curve/pkgs/container/left-curve%2Fdango) |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "| **Architectures** | amd64, arm64 |" >> $GITHUB_STEP_SUMMARY
          if [ -n "$DIGEST_TABLE" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## 🔏 Signed Image Digests" >> $GITHUB_STEP_SUMMARY
            echo "$DIGEST_TABLE" >> $GITHUB_STEP_SUMMARY
          fi

  frontend-build:
    needs: [backend-test]
    permissions:
      packages: write
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: amd64
            runner: [self-hosted]
          # NOTE: building arm on `self-hosted` is very very slow
          - arch: arm64
            runner: ubuntu-24.04-arm
    name: Build frontend for ${{ matrix.arch }} on ${{ join(matrix.runner, ', ') }}
    runs-on: ${{ matrix.runner }}
    env:
      GITHUB_USER: ${{ github.actor }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref || github.ref }}

      - uses: docker/setup-buildx-action@v3

      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set build config
        id: config
        run: |
          set -euo pipefail
          if [[ "${{ matrix.arch }}" == "amd64" ]]; then
            echo "target=x86_64-unknown-linux-gnu" >> $GITHUB_OUTPUT
            echo "platform=linux/amd64" >> $GITHUB_OUTPUT
            echo "suffix=amd64" >> $GITHUB_OUTPUT
          elif [[ "${{ matrix.arch }}" == "arm64" ]]; then
            echo "target=aarch64-unknown-linux-gnu" >> $GITHUB_OUTPUT
            echo "platform=linux/arm64" >> $GITHUB_OUTPUT
            echo "suffix=arm64" >> $GITHUB_OUTPUT
          else
              echo "Unsupported matrix ${{ matrix.arch }}"
              exit 1
          fi

      - name: build docker image
        run: |
          set -euo pipefail
          docker buildx build \
            --push \
            --platform ${{ steps.config.outputs.platform }} \
            --build-arg TARGET_ARCH=${{ steps.config.outputs.target }} \
            --build-arg GIT_COMMIT=${{ env.GIT_COMMIT }} \
            --build-arg GITHUB_TOKEN=${{ env.GITHUB_TOKEN }} \
            --build-arg PRIVY_APP_ID=${{ vars.PRIVY_APP_ID_DEV }} \
            --build-arg PRIVY_CLIENT_ID=${{ vars.PRIVY_CLIENT_ID_DEV }} \
            --provenance=false \
            -t ghcr.io/left-curve/left-curve/dango-frontend:${{ env.GIT_COMMIT }}-${{ steps.config.outputs.suffix }} \
            -f docker/dango-frontend/Dockerfile .

  frontend-push-manifest:
    permissions:
      packages: write
      id-token: write
    needs: [frontend-build]
    runs-on: [self-hosted]
    steps:
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push multi-arch Docker manifest
        run: |
          docker manifest create ghcr.io/left-curve/left-curve/dango-frontend:${{ env.GIT_COMMIT }} \
            --amend ghcr.io/left-curve/left-curve/dango-frontend:${{ env.GIT_COMMIT }}-amd64 \
            --amend ghcr.io/left-curve/left-curve/dango-frontend:${{ env.GIT_COMMIT }}-arm64

          docker manifest push --purge ghcr.io/left-curve/left-curve/dango-frontend:${{ env.GIT_COMMIT }}

          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            docker manifest create ghcr.io/left-curve/left-curve/dango-frontend:latest \
              --amend ghcr.io/left-curve/left-curve/dango-frontend:${{ env.GIT_COMMIT }}-amd64 \
              --amend ghcr.io/left-curve/left-curve/dango-frontend:${{ env.GIT_COMMIT }}-arm64

            docker manifest push --purge ghcr.io/left-curve/left-curve/dango-frontend:latest
          fi

          if [ "${{ github.event_name }}" == "pull_request" ]; then
            docker manifest create ghcr.io/left-curve/left-curve/dango-frontend:pr-${{ github.event.pull_request.number }}-latest\
              --amend ghcr.io/left-curve/left-curve/dango-frontend:${{ env.GIT_COMMIT }}-amd64 \
              --amend ghcr.io/left-curve/left-curve/dango-frontend:${{ env.GIT_COMMIT }}-arm64

            docker manifest push --purge ghcr.io/left-curve/left-curve/dango-frontend:pr-${{ github.event.pull_request.number }}-latest
          fi
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.10.0
      - name: Sign frontend images
        id: sign-frontend
        env:
          COSIGN_EXPERIMENTAL: "true"
          COSIGN_YES: "true"
        run: |
          set -euo pipefail

          images=("ghcr.io/left-curve/left-curve/dango-frontend:${{ env.GIT_COMMIT }}")
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            images+=("ghcr.io/left-curve/left-curve/dango-frontend:latest")
          fi
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            images+=("ghcr.io/left-curve/left-curve/dango-frontend:pr-${{ github.event.pull_request.number }}-latest")
          fi

          tmp_markdown="$(mktemp)"
          {
            echo "| Image | Digest |"
            echo "| ---- | ------ |"
          } > "$tmp_markdown"

          for image in "${images[@]}"; do
            cosign sign --keyless "$image"
            digest="$(docker buildx imagetools inspect "$image" | awk '/^Digest:/ {print $2; exit}')"
            if [ -z "$digest" ]; then
              echo "Unable to determine digest for $image" >&2
              exit 1
            fi
            printf '| %s | `%s` |\n' "$image" "$digest" >> "$tmp_markdown"
          done

          {
            echo "digest_table<<'EOF'"
            cat "$tmp_markdown"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Frontend Docker Deploy Summary
        env:
          DIGEST_TABLE: ${{ steps.sign-frontend.outputs.digest_table }}
        run: |
          echo "# 🎨 Frontend Docker Multi-arch Manifest" >> $GITHUB_STEP_SUMMARY
          echo "| Name | Result |" >> $GITHUB_STEP_SUMMARY
          echo "| ---- | ------ |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | \`${{ env.GIT_COMMIT }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Status** | ✅ |" >> $GITHUB_STEP_SUMMARY
          echo "| **Image URL** | [ghcr.io/left-curve/left-curve/dango-frontend:${{ env.GIT_COMMIT }}](https://github.com/left-curve/left-curve/pkgs/container/left-curve%2Fdango-frontend) |" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "| **Latest tag:** | [ghcr.io/left-curve/left-curve/dango-frontend:latest](https://github.com/left-curve/left-curve/pkgs/container/left-curve%2Fdango-frontend) |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "| **Architectures** | amd64, arm64 |" >> $GITHUB_STEP_SUMMARY
          if [ -n "$DIGEST_TABLE" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## 🔏 Signed Image Digests" >> $GITHUB_STEP_SUMMARY
            echo "$DIGEST_TABLE" >> $GITHUB_STEP_SUMMARY
          fi

  cometbft-manual-sign:
    if: ${{ github.event_name == 'workflow_dispatch' && inputs.cometbft_tag != '' }}
    name: Sign existing CometBFT image
    runs-on: ubuntu-latest
    permissions:
      packages: write
      id-token: write
      contents: read
    steps:
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.10.0

      - name: Resolve digest
        id: cometbft-digest
        env:
          IMAGE: "ghcr.io/left-curve/left-curve/cometbft:${{ inputs.cometbft_tag }}"
          PROVIDED_DIGEST: ${{ inputs.cometbft_digest }}
        run: |
          set -euo pipefail
          if [ -n "$PROVIDED_DIGEST" ]; then
            digest="$PROVIDED_DIGEST"
          else
            inspect_output="$(docker buildx imagetools inspect "$IMAGE" || true)"
            digest="$(grep -m1 '^Digest:' <<<"$inspect_output" | awk '{print $2}')"
          fi

          if [ -z "${digest:-}" ]; then
            echo "::error::Unable to resolve digest for $IMAGE. Provide it explicitly via workflow input or ensure the tag exists."
            exit 1
          fi

          echo "digest=$digest" >> "$GITHUB_OUTPUT"

      - name: Sign existing CometBFT tag
        env:
          COSIGN_EXPERIMENTAL: "true"
          COSIGN_YES: "true"
          IMAGE: "ghcr.io/left-curve/left-curve/cometbft:${{ inputs.cometbft_tag }}"
          DIGEST: ${{ steps.cometbft-digest.outputs.digest }}
        run: |
          set -euo pipefail
          if [[ "$DIGEST" == *@* ]]; then
            target="$DIGEST"
          else
            target="$IMAGE@$DIGEST"
          fi
          cosign sign --keyless "$target"

      - name: Summary
        env:
          DIGEST: ${{ steps.cometbft-digest.outputs.digest }}
        run: |
          {
            echo "## 🔏 CometBFT image signed"
            echo ""
            echo "| Image | Digest |"
            echo "| ----- | ------ |"
            echo "| ghcr.io/left-curve/left-curve/cometbft:${{ inputs.cometbft_tag }} | \`$DIGEST\` |"
          } >> "$GITHUB_STEP_SUMMARY"

  deploy:
    permissions:
      packages: read
      deployments: write
    needs: [frontend-push-manifest, backend-push-manifest]
    runs-on: [self-hosted]
    env:
      PR_NUMBER: ${{ github.event.pull_request.number }}
      PR_BRANCH: ${{ github.event.pull_request.head.ref }}
      ANSIBLE_VAULT_PASSWORD: ${{ secrets.ANSIBLE_VAULT_PASSWORD }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref || github.ref }}
      - name: Check DEPLOY_KEY is set
        run: |
          if [ -z "${{ secrets.DEPLOY_KEY }}" ]; then
            echo "Missing DEPLOY_KEY secret"
            exit 1
          fi
      - name: Start SSH agent
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_KEY }}
      - name: Install Ansible
        run: |
          pipx install ansible
          echo "${HOME}/.local/bin" >> $GITHUB_PATH
          ln -sf ~/.local/pipx/venvs/ansible/bin/ansible-galaxy ~/.local/bin/ansible-galaxy
          ln -sf ~/.local/pipx/venvs/ansible/bin/ansible-playbook ~/.local/bin/ansible-playbook
      - name: Install collections
        run: |
          ansible-galaxy collection install -r deploy/requirements.yml
      - name: Run Ansible playbook
        run: |
          cd deploy

          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
          ansible-playbook full-app.yml -e '{"traefik_enabled": true, "cometbft_generate_keys": true, "dex_bot_enabled": true, "github_deployments_enabled": true, "expose_ports": false, "delete_postgres_database_at_merge": true, "delete_clickhouse_database_at_merge": true, "deploy_includes_postgres": false, "deploy_includes_clickhouse": false, "dango_network": "devnet", "chain_id": "dev-9", "deploy_env": "production", "frontend_banner": "You are using devnet"}' -e github_sha=${{ env.GIT_COMMIT }}
          fi

          if [ "${{ github.event_name }}" == "pull_request" ]; then
          ansible-playbook full-app.yml -e dango_network=pr-${{ github.event.pull_request.number }} -e deployment_name=pr-${{ github.event.pull_request.number }} -e github_pr_number=${{ github.event.pull_request.number }} -e github_sha=${{ github.event.pull_request.head.sha }} -e '{"expose_ports": true, "cometbft_generate_keys": true, "dex_bot_enabled": true, "github_deployments_enabled": true, "frontend_banner": "Preview app from PR ${{ github.event.pull_request.number }}"}' -e deploy_env=preview
          fi

  localdango:
    timeout-minutes: 5
    name: Testing localdango
    runs-on: [self-hosted]
    needs: [frontend-push-manifest, backend-push-manifest]
    permissions:
      packages: read
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref || github.ref }}
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Ensure localdango works
        env:
          DANGO_TAG: ${{ env.GIT_COMMIT }}
          POSTGRES_PORT: 0
          CLICKHOUSE_PORT: 0
          DANGO_PORT: 0
          COMETBFT_PORT: 0
          COMETBFT_TAG: v0.38.17
        run: |
          cd networks/localdango
          docker compose --profile dango down -v
          docker compose --profile dango up -d --wait || {
            echo "Services failed to become healthy"
            docker compose ps
            docker compose logs
            exit 1
          }
      - name: Cleanup
        if: always()
        run: |
          cd networks/localdango
          docker compose --profile dango down -v || true
